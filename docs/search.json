[
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "Plant Pathology in Thai",
    "section": "Welcome",
    "text": "Welcome\nThis is the website for “Hands-On Programming with R”. This book will teach you how to program in R, with hands-on examples. I wrote it for non-programmers to provide a friendly introduction to the R language. You’ll learn how to load data, assemble and disassemble data objects, navigate R’s environment system, write your own functions, and use all of R’s programming tools. Throughout the book, you’ll use your newfound skills to solve practical data science problems.\nIf you are already comfortable with R, and would like to focus instead how to analyze data using R’s Tidyverse packages, I recommend R for Data Science, a book that I co-authored with Hadley Wickham.\n\n\n\n\n\n\nThis book was originally created using bookdown and published at https://rstudio-education.github.io/hopr/. This site is a port of the original book source to the Quarto publishing system in order to provide an example of it’s use."
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Plant Pathology in Thai",
    "section": "License",
    "text": "License\nThis website is (and will always be) free to use, and is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 4.0 License. If you’d like a physical copy of the book, you can order it from amazon; it was published by O’Reilly in July 2014. If you’d like to give back, please consider reporting a typo or leaving a pull request at github.com/rstudio-education/hopr."
  },
  {
    "objectID": "preface.html#conventions-used-in-this-book",
    "href": "preface.html#conventions-used-in-this-book",
    "title": "คำนำ",
    "section": "Conventions Used in This Book",
    "text": "Conventions Used in This Book\nThe following typographical conventions are used in this book:\nItalic:: Indicates new terms, URLs, email addresses, filenames, and file extensions.\nConstant width:: Used for program listings, as well as within paragraphs to refer to program elements such as variable or function names, databases, data types, environment variables, statements, and keywords.\nConstant width bold:: Shows commands or other text that should be typed literally by the user.\nConstant width italic:: Shows text that should be replaced with user-supplied values or by values determined by context.\nTo comment or ask technical questions about this book, please file an issue at github.com/rstudio-education/hopr."
  },
  {
    "objectID": "preface.html#acknowledgments",
    "href": "preface.html#acknowledgments",
    "title": "คำนำ",
    "section": "Acknowledgments",
    "text": "Acknowledgments\nMany excellent people have helped me write this book, from my two editors, Courtney Nash and Julie Steele, to the rest of the O’Reilly team, who designed, proofread, and indexed the book. Also, Greg Snow generously let me quote him in this preface. I offer them all my heartfelt thanks.\nI would also like to thank Hadley Wickham, who has shaped the way I think about and teach R. Many of the ideas in this book come from Statistics 405, a course that I helped Hadley teach when I was a PhD student at Rice University.\nFurther ideas came from the students and teachers of Introduction to Data Science with R, a workshop that I teach on behalf of RStudio. Thank you to all of you. I’d like to offer special thanks to my teaching assistants Josh Paulson, Winston Chang, Jaime Ramos, Jay Emerson, and Vivian Zhang.\nThank you also to JJ Allaire and the rest of my colleagues at RStudio who provide the RStudio IDE, a tool that makes it much easier to use, teach, and write about R.\nFinally, I would like to thank my wife, Kristin, for her support and understanding while I wrote this book."
  },
  {
    "objectID": "dice.html",
    "href": "dice.html",
    "title": "ตอนที่ 1: Weighted Dice",
    "section": "",
    "text": "Computers let you assemble, manipulate, and visualize data sets, all at speeds that would have wowed yesterday’s scientists. In short, computers give you scientific superpowers! But if you wish to use them, you’ll need to pick up some programming skills.\nAs a data scientist who knows how to program, you will improve your ability to:\n\nMemorize (store) entire data sets\nRecall data values on demand\nPerform complex calculations with large amounts of data\nDo repetitive tasks without becoming careless or bored\n\nComputers can do all of these things quickly and error free, which lets your mind do the things it does well: make decisions and assign meaning.\nSound exciting? Great! Let’s begin.\nWhen I was a college student, I sometimes daydreamed of going to Las Vegas. I thought that knowing statistics might help me win big. If that’s what led you to data science, you better sit down; I have some bad news. Even a statistician will lose money in a casino over the long run. This is because the odds for each game are always stacked in the casino’s favor. However, there is a loophole to this rule. You can make money–and reliably too. All you have to do is be the casino.\nBelieve it or not, R can help you do that. Over the course of the book, you will use R to build three virtual objects: a pair of dice that you can roll to generate random numbers, a deck of cards that you can shuffle and deal from, and a slot machine modeled after some real-life video lottery terminals. After that, you’ll just need to add some video graphics and a bank account (and maybe get a few government licenses), and you’ll be in business. I’ll leave those details to you.\nThese projects are lighthearted, but they are also deep. As you complete them, you will become an expert at the skills you need to work with data as a data scientist. You will learn how to store data in your computer’s memory, how to access data that is already there, and how to transform data values in memory when necessary. You will also learn how to write your own programs in R that you can use to analyze data and run simulations.\nIf simulating a slot machine (or dice, or cards) seems frivilous, think of it this way: playing a slot machine is a process. Once you can simulate it, you’ll be able to simulate other processes, such as bootstrap sampling, Markov chain Monte Carlo, and other data-analysis procedures. Plus, these projects provide concrete examples for learning all of the components of R programming: objects, data types, classes, notation, functions, environments, if trees, loops, and vectorization. This first project will make it easier to study these things by teaching you the basics of R.\nYour first mission is simple: assemble R code that will simulate rolling a pair of dice, like at a craps table. Once you have done that, we’ll weight the dice a bit in your favor, just to keep things interesting.\nIn this project, you will learn how to:\n\nUse the R and RStudio interfaces\nRun R commands\nCreate R objects\nWrite your own R functions and scripts\nLoad and use R packages\nGenerate random samples\nCreate quick plots\nGet help when you need it\n\nDon’t worry if it seems like we cover a lot of ground fast. This project is designed to give you a concise overview of the R language. You will return to many of the concepts we meet here in projects 2 and 3, where you will examine the concepts in depth.\nYou’ll need to have both R and RStudio installed on your computer before you can use them. Both are free and easy to download. See Appendix A for complete instructions. If you are ready to begin, open RStudio on your computer and read on."
  },
  {
    "objectID": "basics.html#the-r-user-interface",
    "href": "basics.html#the-r-user-interface",
    "title": "1  The Very Basics",
    "section": "1.1 The R User Interface",
    "text": "1.1 The R User Interface\nBefore you can ask your computer to save some numbers, you’ll need to know how to talk to it. That’s where R and RStudio come in. RStudio gives you a way to talk to your computer. R gives you a language to speak in. To get started, open RStudio just as you would open any other application on your computer. When you do, a window should appear in your screen like the one shown in Figure 1.1.\n\n\n\nFigure 1.1: Your computer does your bidding when you type R commands at the prompt in the bottom line of the console pane. Don’t forget to hit the Enter key. When you first open RStudio, the console appears in the pane on your left, but you can change this with File &gt; Preferences in the menu bar.\n\n\n\n\n\n\n\n\nNote\n\n\n\nIf you do not yet have R and RStudio installed on your computer–or do not know what I am talking about–visit Appendix A. The appendix will give you an overview of the two free tools and tell you how to download them.\n\n\nThe RStudio interface is simple. You type R code into the bottom line of the RStudio console pane and then click Enter to run it. The code you type is called a command, because it will command your computer to do something for you. The line you type it into is called the command line.\nWhen you type a command at the prompt and hit Enter, your computer executes the command and shows you the results. Then RStudio displays a fresh prompt for your next command. For example, if you type 1 + 1 and hit Enter, RStudio will display:\n&gt; 1 + 1\n[1] 2\n&gt;\nYou’ll notice that a [1] appears next to your result. R is just letting you know that this line begins with the first value in your result. Some commands return more than one value, and their results may fill up multiple lines. For example, the command 100:130 returns 31 values; it creates a sequence of integers from 100 to 130. Notice that new bracketed numbers appear at the start of the second and third lines of output. These numbers just mean that the second line begins with the 14th value in the result, and the third line begins with the 25th value. You can mostly ignore the numbers that appear in brackets:\n&gt; 100:130\n [1] 100 101 102 103 104 105 106 107 108 109 110 111 112\n[14] 113 114 115 116 117 118 119 120 121 122 123 124 125\n[25] 126 127 128 129 130\n\n\n\n\n\n\nTip\n\n\n\nThe colon operator (:) returns every integer between two integers. It is an easy way to create a sequence of numbers.\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou may hear me speak of R in the third person. For example, I might say, “Tell R to do this” or “Tell R to do that”, but of course R can’t do anything; it is just a language. This way of speaking is shorthand for saying, “Tell your computer to do this by writing a command in the R language at the command line of your RStudio console.” Your computer, and not R, does the actual work.\nIs this shorthand confusing and slightly lazy to use? Yes. Do a lot of people use it? Everyone I know–probably because it is so convenient.\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn some languages, like C, Java, and FORTRAN, you have to compile your human-readable code into machine-readable code (often 1s and 0s) before you can run it. If you’ve programmed in such a language before, you may wonder whether you have to compile your R code before you can use it. The answer is no. R is a dynamic programming language, which means R automatically interprets your code as you run it.\n\n\nIf you type an incomplete command and press Enter, R will display a + prompt, which means R is waiting for you to type the rest of your command. Either finish the command or hit Escape to start over:\n&gt; 5 -\n+\n+ 1\n[1] 4\nIf you type a command that R doesn’t recognize, R will return an error message. If you ever see an error message, don’t panic. R is just telling you that your computer couldn’t understand or do what you asked it to do. You can then try a different command at the next prompt:\n&gt; 3 % 5\nError: unexpected input in \"3 % 5\"\n&gt;\nOnce you get the hang of the command line, you can easily do anything in R that you would do with a calculator. For example, you could do some basic arithmetic:\n2 * 3   \n## 6\n\n4 - 1   \n## 3\n\n6 / (4 - 1)   \n## 2\nDid you notice something different about this code? I’ve left out the &gt;’s and [1]’s. This will make the code easier to copy and paste if you want to put it in your own console.\nR treats the hashtag character, #, in a special way; R will not run anything that follows a hashtag on a line. This makes hashtags very useful for adding comments and annotations to your code. Humans will be able to read the comments, but your computer will pass over them. The hashtag is known as the commenting symbol in R.\nFor the remainder of the book, I’ll use hashtags to display the output of R code. I’ll use a single hashtag to add my own comments and a double hashtag, ##, to display the results of code. I’ll avoid showing &gt;s and [1]s unless I want you to look at them.\n\n\n\n\n\n\nImportant\n\n\n\nSome R commands may take a long time to run. You can cancel a command once it has begun by pressing ctrl + c. Note that it may also take R a long time to cancel the command.\n\n\n\n\n\n\n\n\nExercise: Magic with Numbers\n\n\n\nThat’s the basic interface for executing R code in RStudio. Think you have it? If so, try doing these simple tasks. If you execute everything correctly, you should end up with the same number that you started with:\n\nChoose any number and add 2 to it.\nMultiply the result by 3.\nSubtract 6 from the answer.\nDivide what you get by 3.\n\n\n\nThroughout the book, I’ll put exercises in chunks, like the one above. I’ll follow each exercise with a model answer, like the one below.\nYou could start with the number 10, and then do the following steps:\n10 + 2\n## 12\n\n12 * 3\n## 36\n\n36 - 6\n## 30\n\n30 / 3\n## 10"
  },
  {
    "objectID": "basics.html#objects",
    "href": "basics.html#objects",
    "title": "1  The Very Basics",
    "section": "1.2 Objects",
    "text": "1.2 Objects\nNow that you know how to use R, let’s use it to make a virtual die. The : operator from a couple of pages ago gives you a nice way to create a group of numbers from one to six. The : operator returns its results as a vector, a one-dimensional set of numbers:\n1:6\n## 1 2 3 4 5 6\nThat’s all there is to how a virtual die looks! But you are not done yet. Running 1:6 generated a vector of numbers for you to see, but it didn’t save that vector anywhere in your computer’s memory. What you are looking at is basically the footprints of six numbers that existed briefly and then melted back into your computer’s RAM. If you want to use those numbers again, you’ll have to ask your computer to save them somewhere. You can do that by creating an R object.\nR lets you save data by storing it inside an R object. What is an object? Just a name that you can use to call up stored data. For example, you can save data into an object like a or b. Wherever R encounters the object, it will replace it with the data saved inside, like so:\na &lt;- 1\na\n## 1\n\na + 2\n## 3\n\n\n\n\n\n\nNote\n\n\n\n\nTo create an R object, choose a name and then use the less-than symbol, &lt;, followed by a minus sign, -, to save data into it. This combination looks like an arrow, &lt;-. R will make an object, give it your name, and store in it whatever follows the arrow. So a &lt;- 1 stores 1 in an object named a.\nWhen you ask R what’s in a, R tells you on the next line.\nYou can use your object in new R commands, too. Since a previously stored the value of 1, you’re now adding 1 to 2.\n\n\n\nSo, for another example, the following code would create an object named die that contains the numbers one through six. To see what is stored in an object, just type the object’s name by itself:\ndie &lt;- 1:6\n\ndie\n## 1 2 3 4 5 6\nWhen you create an object, the object will appear in the environment pane of RStudio, as shown in Figure 1.2. This pane will show you all of the objects you’ve created since opening RStudio.\n\n\n\nFigure 1.2: The RStudio environment pane keeps track of the R objects you create.\n\n\nYou can name an object in R almost anything you want, but there are a few rules. First, a name cannot start with a number. Second, a name cannot use some special symbols, like ^, !, $, @, +, -, /, or *:\n\n\n\nGood names\nNames that cause errors\n\n\n\n\na\n1trial\n\n\nb\n$\n\n\nFOO\n^mean\n\n\nmy_var\n2nd\n\n\n.day\n!bad\n\n\n\n\n\n\n\n\n\nCapitalization\n\n\n\nR is case-sensitive, so name and Name will refer to different objects:\nName &lt;- 1\nname &lt;- 0  \n  \nName + 1  \n## 2  \n\n\nFinally, R will overwrite any previous information stored in an object without asking you for permission. So, it is a good idea to not use names that are already taken:\nmy_number &lt;- 1\nmy_number \n## 1\n\nmy_number &lt;- 999\nmy_number\n## 999\nYou can see which object names you have already used with the function ls:\nls()\n## \"a\"         \"die\"       \"my_number\" \"name\"     \"Name\"     \nYou can also see which names you have used by examining RStudio’s environment pane.\nYou now have a virtual die that is stored in your computer’s memory. You can access it whenever you like by typing the word die. So what can you do with this die? Quite a lot. R will replace an object with its contents whenever the object’s name appears in a command. So, for example, you can do all sorts of math with the die. Math isn’t so helpful for rolling dice, but manipulating sets of numbers will be your stock and trade as a data scientist. So let’s take a look at how to do that:\ndie - 1\n## 0 1 2 3 4 5\n\ndie / 2\n## 0.5 1.0 1.5 2.0 2.5 3.0\n\ndie * die\n## 1  4  9 16 25 36\nIf you are a big fan of linear algebra (and who isn’t?), you may notice that R does not always follow the rules of matrix multiplication. Instead, R uses element-wise execution. When you manipulate a set of numbers, R will apply the same operation to each element in the set. So for example, when you run die - 1, R subtracts one from each element of die.\nWhen you use two or more vectors in an operation, R will line up the vectors and perform a sequence of individual operations. For example, when you run die * die, R lines up the two die vectors and then multiplies the first element of vector 1 by the first element of vector 2. R then multiplies the second element of vector 1 by the second element of vector 2, and so on, until every element has been multiplied. The result will be a new vector the same length as the first two, as shown in Figure 1.3.\n\n\n\nFigure 1.3: When R performs element-wise execution, it matches up vectors and then manipulates each pair of elements independently.\n\n\nIf you give R two vectors of unequal lengths, R will repeat the shorter vector until it is as long as the longer vector, and then do the math, as shown in Figure 1.4. This isn’t a permanent change–the shorter vector will be its original size after R does the math. If the length of the short vector does not divide evenly into the length of the long vector, R will return a warning message. This behavior is known as vector recycling, and it helps R do element-wise operations:\n1:2\n## 1 2\n\n1:4\n## 1 2 3 4\n\ndie\n## 1 2 3 4 5 6\n\ndie + 1:2\n## 2 4 4 6 6 8\n\ndie + 1:4\n## 2 4 6 8 6 8\nWarning message:\nIn die + 1:4 :\n  longer object length is not a multiple of shorter object length\n\n\n\nFigure 1.4: R will repeat a short vector to do element-wise operations with two vectors of uneven lengths.\n\n\nElement-wise operations are a very useful feature in R because they manipulate groups of values in an orderly way. When you start working with data sets, element-wise operations will ensure that values from one observation or case are only paired with values from the same observation or case. Element-wise operations also make it easier to write your own programs and functions in R.\nBut don’t think that R has given up on traditional matrix multiplication. You just have to ask for it when you want it. You can do inner multiplication with the %*% operator and outer multiplication with the %o% operator:\ndie %*% die\n## 91\n\ndie %o% die\n##      [,1] [,2] [,3] [,4] [,5] [,6]\n## [1,]    1    2    3    4    5    6\n## [2,]    2    4    6    8   10   12\n## [3,]    3    6    9   12   15   18\n## [4,]    4    8   12   16   20   24\n## [5,]    5   10   15   20   25   30\n## [6,]    6   12   18   24   30   36\nYou can also do things like transpose a matrix with t and take its determinant with det.\nDon’t worry if you’re not familiar with these operations. They are easy to look up, and you won’t need them for this book.\nNow that you can do math with your die object, let’s look at how you could “roll” it. Rolling your die will require something more sophisticated than basic arithmetic; you’ll need to randomly select one of the die’s values. And for that, you will need a function."
  },
  {
    "objectID": "basics.html#functions",
    "href": "basics.html#functions",
    "title": "1  The Very Basics",
    "section": "1.3 Functions",
    "text": "1.3 Functions\nR comes with many functions that you can use to do sophisticated tasks like random sampling. For example, you can round a number with the round function, or calculate its factorial with the factorial function. Using a function is pretty simple. Just write the name of the function and then the data you want the function to operate on in parentheses:\nround(3.1415)\n## 3\n\nfactorial(3)\n## 6\nThe data that you pass into the function is called the function’s argument. The argument can be raw data, an R object, or even the results of another R function. In this last case, R will work from the innermost function to the outermost, as in Figure 1.5.\nmean(1:6)\n## 3.5\n\nmean(die)\n## 3.5\n\nround(mean(die))\n## 4\n\n\n\nFigure 1.5: When you link functions together, R will resolve them from the innermost operation to the outermost. Here R first looks up die, then calculates the mean of one through six, then rounds the mean.\n\n\nLucky for us, there is an R function that can help “roll” the die. You can simulate a roll of the die with R’s sample function. sample takes two arguments: a vector named x and a number named size. sample will return size elements from the vector:\nsample(x = 1:4, size = 2)\n## 3 2\nTo roll your die and get a number back, set x to die and sample one element from it. You’ll get a new (maybe different) number each time you roll it:\nsample(x = die, size = 1)\n## 2\n\nsample(x = die, size = 1)\n## 1\n\nsample(x = die, size = 1)\n## 6\nMany R functions take multiple arguments that help them do their job. You can give a function as many arguments as you like as long as you separate each argument with a comma.\nYou may have noticed that I set die and 1 equal to the names of the arguments in sample, x and size. Every argument in every R function has a name. You can specify which data should be assigned to which argument by setting a name equal to data, as in the preceding code. This becomes important as you begin to pass multiple arguments to the same function; names help you avoid passing the wrong data to the wrong argument. However, using names is optional. You will notice that R users do not often use the name of the first argument in a function. So you might see the previous code written as:\nsample(die, size = 1)\n## 2\nOften, the name of the first argument is not very descriptive, and it is usually obvious what the first piece of data refers to anyways.\nBut how do you know which argument names to use? If you try to use a name that a function does not expect, you will likely get an error:\nround(3.1415, corners = 2)\n## Error in round(3.1415, corners = 2) : unused argument(s) (corners = 2)\nIf you’re not sure which names to use with a function, you can look up the function’s arguments with args. To do this, place the name of the function in the parentheses behind args. For example, you can see that the round function takes two arguments, one named x and one named digits:\nargs(round)\n## function (x, digits = 0) \n## NULL\nDid you notice that args shows that the digits argument of round is already set to 0? Frequently, an R function will take optional arguments like digits. These arguments are considered optional because they come with a default value. You can pass a new value to an optional argument if you want, and R will use the default value if you do not. For example, round will round your number to 0 digits past the decimal point by default. To override the default, supply your own value for digits:\nround(3.1415)\n## 3\n\nround(3.1415, digits = 2)\n## 3.14\nYou should write out the names of each argument after the first one or two when you call a function with multiple arguments. Why? First, this will help you and others understand your code. It is usually obvious which argument your first input refers to (and sometimes the second input as well). However, you’d need a large memory to remember the third and fourth arguments of every R function. Second, and more importantly, writing out argument names prevents errors.\nIf you do not write out the names of your arguments, R will match your values to the arguments in your function by order. For example, in the following code, the first value, die, will be matched to the first argument of sample, which is named x. The next value, 1, will be matched to the next argument, size:\nsample(die, 1)\n## 2\nAs you provide more arguments, it becomes more likely that your order and R’s order may not align. As a result, values may get passed to the wrong argument. Argument names prevent this. R will always match a value to its argument name, no matter where it appears in the order of arguments:\nsample(size = 1, x = die)\n## 2\n\n1.3.1 Sample with Replacement\nIf you set size = 2, you can almost simulate a pair of dice. Before we run that code, think for a minute why that might be the case. sample will return two numbers, one for each die:\nsample(die, size = 2)\n## 3 4\nI said this “almost” works because this method does something funny. If you use it many times, you’ll notice that the second die never has the same value as the first die, which means you’ll never roll something like a pair of threes or snake eyes. What is going on?\nBy default, sample builds a sample without replacement. To see what this means, imagine that sample places all of the values of die in a jar or urn. Then imagine that sample reaches into the jar and pulls out values one by one to build its sample. Once a value has been drawn from the jar, sample sets it aside. The value doesn’t go back into the jar, so it cannot be drawn again. So if sample selects a six on its first draw, it will not be able to select a six on the second draw; six is no longer in the jar to be selected. Although sample creates its sample electronically, it follows this seemingly physical behavior.\nOne side effect of this behavior is that each draw depends on the draws that come before it. In the real world, however, when you roll a pair of dice, each die is independent of the other. If the first die comes up six, it does not prevent the second die from coming up six. In fact, it doesn’t influence the second die in any way whatsoever. You can recreate this behavior in sample by adding the argument replace = TRUE:\nsample(die, size = 2, replace = TRUE)\n## 5 5\nThe argument replace = TRUE causes sample to sample with replacement. Our jar example provides a good way to understand the difference between sampling with replacement and without. When sample uses replacement, it draws a value from the jar and records the value. Then it puts the value back into the jar. In other words, sample replaces each value after each draw. As a result, sample may select the same value on the second draw. Each value has a chance of being selected each time. It is as if every draw were the first draw.\nSampling with replacement is an easy way to create independent random samples. Each value in your sample will be a sample of size one that is independent of the other values. This is the correct way to simulate a pair of dice:\nsample(die, size = 2, replace = TRUE)\n## 2 4\nCongratulate yourself; you’ve just run your first simulation in R! You now have a method for simulating the result of rolling a pair of dice. If you want to add up the dice, you can feed your result straight into the sum function:\ndice &lt;- sample(die, size = 2, replace = TRUE)\ndice\n## 2 4\n\nsum(dice)\n## 6\nWhat would happen if you call dice multiple times? Would R generate a new pair of dice values each time? Let’s give it a try:\ndice\n## 2 4\n\ndice\n## 2 4\n\ndice\n## 2 4\nNope. Each time you call dice, R will show you the result of that one time you called sample and saved the output to dice. R won’t rerun sample(die, 2, replace = TRUE) to create a new roll of the dice. This is a relief in a way. Once you save a set of results to an R object, those results do not change. Programming would be quite hard if the values of your objects changed each time you called them.\nHowever, it would be convenient to have an object that can re-roll the dice whenever you call it. You can make such an object by writing your own R function."
  },
  {
    "objectID": "basics.html#sec-write-functions",
    "href": "basics.html#sec-write-functions",
    "title": "1  The Very Basics",
    "section": "1.4 Writing Your Own Functions",
    "text": "1.4 Writing Your Own Functions\nTo recap, you already have working R code that simulates rolling a pair of dice:\ndie &lt;- 1:6\ndice &lt;- sample(die, size = 2, replace = TRUE)\nsum(dice)\nYou can retype this code into the console anytime you want to re-roll your dice. However, this is an awkward way to work with the code. It would be easier to use your code if you wrapped it into its own function, which is exactly what we’ll do now. We’re going to write a function named roll that you can use to roll your virtual dice. When you’re finished, the function will work like this: each time you call roll(), R will return the sum of rolling two dice:\nroll()\n## 8 \n\nroll()\n## 3\n\nroll()\n## 7\nFunctions may seem mysterious or fancy, but they are just another type of R object. Instead of containing data, they contain code. This code is stored in a special format that makes it easy to reuse the code in new situations. You can write your own functions by recreating this format.\n\n1.4.1 The Function Constructor\nEvery function in R has three basic parts: a name, a body of code, and a set of arguments. To make your own function, you need to replicate these parts and store them in an R object, which you can do with the function function. To do this, call function() and follow it with a pair of braces, {}:\nmy_function &lt;- function() {}\nfunction will build a function out of whatever R code you place between the braces. For example, you can turn your dice code into a function by calling:\nroll &lt;- function() {\n  die &lt;- 1:6\n  dice &lt;- sample(die, size = 2, replace = TRUE)\n  sum(dice)\n}\n\n\n\n\n\n\nNote\n\n\n\nNotice that I indented each line of code between the braces. This makes the code easier for you and me to read but has no impact on how the code runs. R ignores spaces and line breaks and executes one complete expression at a time.\n\n\nJust hit the Enter key between each line after the first brace, {. R will wait for you to type the last brace, }, before it responds.\nDon’t forget to save the output of function to an R object. This object will become your new function. To use it, write the object’s name followed by an open and closed parenthesis:\nroll()\n## 9\nYou can think of the parentheses as the “trigger” that causes R to run the function. If you type in a function’s name without the parentheses, R will show you the code that is stored inside the function. If you type in the name with the parentheses, R will run that code:\nroll\n## function() {\n##   die &lt;- 1:6\n##   dice &lt;- sample(die, size = 2, replace = TRUE)\n##   sum(dice)\n## }\n\nroll()\n## 6\nThe code that you place inside your function is known as the body of the function. When you run a function in R, R will execute all of the code in the body and then return the result of the last line of code. If the last line of code doesn’t return a value, neither will your function, so you want to ensure that your final line of code returns a value. One way to check this is to think about what would happen if you ran the body of code line by line in the command line. Would R display a result after the last line, or would it not?\nHere’s some code that would display a result:\ndice\n1 + 1\nsqrt(2)\nAnd here’s some code that would not:\ndice &lt;- sample(die, size = 2, replace = TRUE)\ntwo &lt;- 1 + 1\na &lt;- sqrt(2)\nDo you notice the pattern? These lines of code do not return a value to the command line; they save a value to an object."
  },
  {
    "objectID": "basics.html#arguments",
    "href": "basics.html#arguments",
    "title": "1  The Very Basics",
    "section": "1.5 Arguments",
    "text": "1.5 Arguments\nWhat if we removed one line of code from our function and changed the name die to bones, like this?\nroll2 &lt;- function() {\n  dice &lt;- sample(bones, size = 2, replace = TRUE)\n  sum(dice)\n}\nNow I’ll get an error when I run the function. The function needs the object bones to do its job, but there is no object named bones to be found:\nroll2()\n## Error in sample(bones, size = 2, replace = TRUE) : \n##   object 'bones' not found\nYou can supply bones when you call roll2 if you make bones an argument of the function. To do this, put the name bones in the parentheses that follow function when you define roll2:\nroll2 &lt;- function(bones) {\n  dice &lt;- sample(bones, size = 2, replace = TRUE)\n  sum(dice)\n}\nNow roll2 will work as long as you supply bones when you call the function. You can take advantage of this to roll different types of dice each time you call roll2. Dungeons and Dragons, here we come!\nRemember, we’re rolling pairs of dice:\nroll2(bones = 1:4)\n##  3\n\nroll2(bones = 1:6)\n## 10\n\nroll2(1:20)\n## 31\nNotice that roll2 will still give an error if you do not supply a value for the bones argument when you call roll2:\nroll2()\n## Error in sample(bones, size = 2, replace = TRUE) : \n##   argument \"bones\" is missing, with no default\nYou can prevent this error by giving the bones argument a default value. To do this, set bones equal to a value when you define roll2:\nroll2 &lt;- function(bones = 1:6) {\n  dice &lt;- sample(bones, size = 2, replace = TRUE)\n  sum(dice)\n}\nNow you can supply a new value for bones if you like, and roll2 will use the default if you do not:\nroll2()\n## 9\nYou can give your functions as many arguments as you like. Just list their names, separated by commas, in the parentheses that follow function. When the function is run, R will replace each argument name in the function body with the value that the user supplies for the argument. If the user does not supply a value, R will replace the argument name with the argument’s default value (if you defined one).\nTo summarize, function helps you construct your own R functions. You create a body of code for your function to run by writing code between the braces that follow function. You create arguments for your function to use by supplying their names in the parentheses that follow function. Finally, you give your function a name by saving its output to an R object, as shown in Figure 1.6.\nOnce you’ve created your function, R will treat it like every other function in R. Think about how useful this is. Have you ever tried to create a new Excel option and add it to Microsoft’s menu bar? Or a new slide animation and add it to Powerpoint’s options? When you work with a programming language, you can do these types of things. As you learn to program in R, you will be able to create new, customized, reproducible tools for yourself whenever you like. Project 3: Slot Machine will teach you much more about writing functions in R.\n\n\n\nFigure 1.6: Every function in R has the same parts, and you can use function to create these parts. Assign the result to a name, so you can call the function later."
  },
  {
    "objectID": "basics.html#scripts",
    "href": "basics.html#scripts",
    "title": "1  The Very Basics",
    "section": "1.6 Scripts",
    "text": "1.6 Scripts\nWhat if you want to edit roll2 again? You could go back and retype each line of code in roll2, but it would be so much easier if you had a draft of the code to start from. You can create a draft of your code as you go by using an R script. An R script is just a plain text file that you save R code in. You can open an R script in RStudio by going to File &gt; New File &gt; R script in the menu bar. RStudio will then open a fresh script above your console pane, as shown in Figure 1.7.\nI strongly encourage you to write and edit all of your R code in a script before you run it in the console. Why? This habit creates a reproducible record of your work. When you’re finished for the day, you can save your script and then use it to rerun your entire analysis the next day. Scripts are also very handy for editing and proofreading your code, and they make a nice copy of your work to share with others. To save a script, click the scripts pane, and then go to File &gt; Save As in the menu bar.\n\n\n\nFigure 1.7: When you open an R Script (File &gt; New File &gt; R Script in the menu bar), RStudio creates a fourth pane above the console where you can write and edit your code.\n\n\nRStudio comes with many built-in features that make it easy to work with scripts. First, you can automatically execute a line of code in a script by clicking the Run button, as shown in Figure 1.8.\nR will run whichever line of code your cursor is on. If you have a whole section highlighted, R will run the highlighted code. Alternatively, you can run the entire script by clicking the Source button. Don’t like clicking buttons? You can use Control + Return as a shortcut for the Run button. On Macs, that would be Command + Return.\n\n\n\nFigure 1.8: You can run a highlighted portion of code in your script if you click the Run button at the top of the scripts pane. You can run the entire script by clicking the Source button.\n\n\nIf you’re not convinced about scripts, you soon will be. It becomes a pain to write multi-line code in the console’s single-line command line. Let’s avoid that headache and open your first script now before we move to the next chapter.\n\n\n\n\n\n\nExtract function\n\n\n\nRStudio comes with a tool that can help you build functions. To use it, highlight the lines of code in your R script that you want to turn into a function. Then click Code &gt; Extract Function in the menu bar. RStudio will ask you for a function name to use and then wrap your code in a function call. It will scan the code for undefined variables and use these as arguments.\nYou may want to double-check RStudio’s work. It assumes that your code is correct, so if it does something surprising, you may have a problem in your code."
  },
  {
    "objectID": "basics.html#summary",
    "href": "basics.html#summary",
    "title": "1  The Very Basics",
    "section": "1.7 Summary",
    "text": "1.7 Summary\nYou’ve covered a lot of ground already. You now have a virtual die stored in your computer’s memory, as well as your own R function that rolls a pair of dice. You’ve also begun speaking the R language.\nAs you’ve seen, R is a language that you can use to talk to your computer. You write commands in R and run them at the command line for your computer to read. Your computer will sometimes talk back–for example, when you commit an error–but it usually just does what you ask and then displays the result.\nThe two most important components of the R language are objects, which store data, and functions, which manipulate data. R also uses a host of operators like +, -, *, /, and &lt;- to do basic tasks. As a data scientist, you will use R objects to store data in your computer’s memory, and you will use functions to automate tasks and do complicated calculations. We will examine objects in more depth later in Project 2: Playing Cards and dig further into functions in Project 3: Slot Machine. The vocabulary you have developed here will make each of those projects easier to understand. However, we’re not done with your dice yet.\nIn Packages and Help Pages, you’ll run some simulations on your dice and build your first graphs in R. You’ll also look at two of the most useful components of the R language: R packages, which are collections of functions writted by R’s talented community of developers, and R documentation, which is a collection of help pages built into R that explains every function and data set in the language."
  },
  {
    "objectID": "packages.html#packages",
    "href": "packages.html#packages",
    "title": "2  Packages and Help Pages",
    "section": "2.1 Packages",
    "text": "2.1 Packages\nYou’re not the only person writing your own functions with R. Many professors, programmers, and statisticians use R to design tools that can help people analyze data. They then make these tools free for anyone to use. To use these tools, you just have to download them. They come as preassembled collections of functions and objects called packages. Appendix B: R Packages contains detailed instructions for downloading and updating R packages, but we’ll look at the basics here.\nWe’re going to use the qplot function to make some quick plots. qplot comes in the ggplot2 package, a popular package for making graphs. Before you can use qplot, or anything else in the ggplot2 package, you need to download and install it.\n\n2.1.1 install.packages\nEach R package is hosted at http://cran.r-project.org, the same website that hosts R. However, you don’t need to visit the website to download an R package; you can download packages straight from R’s command line. Here’s how:\n\nOpen RStudio.\nMake sure you are connected to the Internet.\nRun install.packages(\"ggplot2\") at the command line.\n\nThat’s it. R will have your computer visit the website, download ggplot2, and install the package in your hard drive right where R wants to find it. You now have the ggplot2 package. If you would like to install another package, replace ggplot2 with your package name in the code.\n\n\n2.1.2 library\nInstalling a package doesn’t place its functions at your fingertips just yet: it simply places them in your hard drive. To use an R package, you next have to load it in your R session with the command library(\"ggplot2\"). If you would like to load a different package, replace ggplot2 with your package name in the code.\nTo see what this does, try an experiment. First, ask R to show you the qplot function. R won’t be able to find qplot because qplot lives in the ggplot2 package, which you haven’t loaded:\nqplot\n## Error: object 'qplot' not found\nNow load the ggplot2 package:\nlibrary(\"ggplot2\")\nIf you installed the package with install.packages as instructed, everything should go fine. Don’t worry if you don’t see any results or messages. No news is fine news when loading a package. Don’t worry if you do see a message either; ggplot2 sometimes displays helpful start up messages. As long as you do not see anything that says “Error,” you are doing fine.\nNow if you ask to see qplot, R will show you quite a bit of code (qplot is a long function):\nqplot\n## (quite a bit of code)\nAppendix B: R Packages contains many more details about acquiring and using packages. I recommend that you read it if you are unfamiliar with R’s package system. The main thing to remember is that you only need to install a package once, but you need to load it with library each time you wish to use it in a new R session. R will unload all of its packages each time you close RStudio.\nNow that you’ve loaded qplot, let’s take it for a spin. qplot makes “quick plots.” If you give qplot two vectors of equal lengths, qplot will draw a scatterplot for you. qplot will use the first vector as a set of x values and the second vector as a set of y values. Look for the plot to appear in the Plots tab of the bottom-right pane in your RStudio window.\nThe following code will make the plot that appears in Figure 2.1. Until now, we’ve been creating sequences of numbers with the : operator; but you can also create vectors of numbers with the c function. Give c all of the numbers that you want to appear in the vector, separated by a comma. c stands for concatenate, but you can think of it as “collect” or “combine”:\nx &lt;- c(-1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1)\nx\n## -1.0 -0.8 -0.6 -0.4 -0.2  0.0  0.2  0.4  0.6  0.8  1.0\n\ny &lt;- x^3\ny\n## -1.000 -0.512 -0.216 -0.064 -0.008  0.000  0.008\n##  0.064  0.216  0.512  1.000\n\nqplot(x, y)\n\n\n\nFigure 2.1: qplot makes a scatterplot when you give it two vectors.\n\n\nYou don’t need to name your vectors x and y. I just did that to make the example clear. As you can see in Figure 2.1, a scatterplot is a set of points, each plotted according to its x and y values. Together, the vectors x and y describe a set of 10 points. How did R match up the values in x and y to make these points? With element-wise execution, as we saw in Figure 1.3.\nScatterplots are useful for visualizing the relationship between two variables. However, we’re going to use a different type of graph, a histogram. A histogram visualizes the distribution of a single variable; it displays how many data points appear at each value of x.\nLet’s take a look at a histogram to see if this makes sense. qplot will make a histogram whenever you give it only one vector to plot. The following code makes the left-hand plot in Figure 2.2 (we’ll worry about the right-hand plot in just second). To make sure our graphs look the same, use the extra argument binwidth = 1:\nx &lt;- c(1, 2, 2, 2, 3, 3)\nqplot(x, binwidth = 1)\n\n\n\nFigure 2.2: qplot makes a histogram when you give it a single vector.\n\n\nThis plot shows that our vector contains one value in the interval [1, 2) by placing a bar of height 1 above that interval. Similarly, the plot shows that the vector contains three values in the interval [2, 3) by placing a bar of height 3 in that interval. It shows that the vector contains two values in the interval [3, 4) by placing a bar of height 2 in that interval. In these intervals, the hard bracket, [, means that the first number is included in the interval. The parenthesis, ), means that the last number is not included.\nLet’s try another histogram. This code makes the right-hand plot in Figure 2.2. Notice that there are five points with a value of 1 in x2. The histogram displays this by plotting a bar of height 5 above the interval x2 = [1, 2):\nx2 &lt;- c(1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 4)\nqplot(x2, binwidth = 1)"
  },
  {
    "objectID": "packages.html#visualize-a-histogram",
    "href": "packages.html#visualize-a-histogram",
    "title": "2  Packages and Help Pages",
    "section": "2.2 Visualize a Histogram",
    "text": "2.2 Visualize a Histogram\nLet x3 be the following vector:\nx3 &lt;- c(0, 1, 1, 2, 2, 2, 3, 3, 4)\nImagine what a histogram of x3 would look like. Assume that the histogram has a bin width of 1. How many bars will the histogram have? Where will they appear? How high will each be?\nWhen you are done, plot a histogram of x3 with binwidth = 1, and see if you are right."
  },
  {
    "objectID": "packages.html#getting-help-with-help-pages",
    "href": "packages.html#getting-help-with-help-pages",
    "title": "2  Packages and Help Pages",
    "section": "2.3 Getting Help with Help Pages",
    "text": "2.3 Getting Help with Help Pages\nThere are over 1,000 functions at the core of R, and new R functions are created all of the time. This can be a lot of material to memorize and learn! Luckily, each R function comes with its own help page, which you can access by typing the function’s name after a question mark. For example, each of these commands will open a help page. Look for the pages to appear in the Help tab of RStudio’s bottom-right pane:\n?sqrt\n?log10\n?sample\nHelp pages contain useful information about what each function does. These help pages also serve as code documentation, so reading them can be bittersweet. They often seem to be written for people who already understand the function and do not need help.\nDon’t let this bother you—you can gain a lot from a help page by scanning it for information that makes sense and glossing over the rest. This technique will inevitably bring you to the most helpful part of each help page: the bottom. Here, almost every help page includes some example code that puts the function in action. Running this code is a great way to learn by example.\n\n\n\n\n\n\nWarning\n\n\n\nIf a function comes in an R package, R won’t be able to find its help page unless the package is loaded.\n\n\n\n2.3.1 Parts of a Help Page\nEach help page is divided into sections. Which sections appear can vary from help page to help page, but you can usually expect to find these useful topics:\nDescription - A short summary of what the function does.\nUsage - An example of how you would type the function. Each argument of the function will appear in the order R expects you to supply it (if you don’t use argument names).\nArguments - A list of each argument the function takes, what type of information R expects you to supply for the argument, and what the function will do with the information.\nDetails - A more in-depth description of the function and how it operates. The details section also gives the function author a chance to alert you to anything you might want to know when using the function.\nValue - A description of what the function returns when you run it.\nSee Also - A short list of related R functions.\nExamples - Example code that uses the function and is guaranteed to work. The examples section of a help page usually demonstrates a couple different ways to use a function. This helps give you an idea of what the function is capable of.\nIf you’d like to look up the help page for a function but have forgotten the function’s name, you can search by keyword. To do this, type two question marks followed by a keyword in R’s command line. R will pull up a list of links to help pages related to the keyword. You can think of this as the help page for the help page:\n??log\nLet’s take a stroll through sample’s help page. Remember: we’re searching for anything that could help you change the probabilities involved in the sampling process. I’m not going to reproduce the whole help page here (just the juiciest parts), so you should follow along on your computer.\nFirst, open the help page. It will appear in the same pane in RStudio as your plots did (but in the Help tab, not the Plots tab):\n?sample\nWhat do you see? Starting from the top:\nRandom Samples and Permutations\n\nDescription\n    sample takes a sample of the specified size from the elements of x using \neither with or without replacement.\nSo far, so good. You knew all of that. The next section, Usage, has a possible clue. It mentions an argument called prob:\nUsage\n    sample(x, size, replace = FALSE, prob = NULL)\nIf you scroll down to the arguments section, the description of +prob+ sounds very promising:\nA vector of probability weights for obtaining the elements of the vector being \nsampled.\nThe Details section confirms our suspicions. In this case, it also tells you how to proceed:\nThe optional prob argument can be used to give a vector of weights for obtaining \nthe elements of the vector being sampled. They need not sum to one, but they \nshould be nonnegative and not all zero.\nAlthough the help page does not say it here, these weights will be matched up to the elements being sampled in element-wise fashion. The first weight will describe the first element, the second weight the second element, and so on. This is common practice in R.\nReading on:\nIf replace is true, Walker's alias method (Ripley, 1987) is used...\nOkay, that looks like time to start skimming. We should have enough info now to figure out how to weight our dice.\n\n\n\n\n\n\nExercise: Roll a Pair of Dice\n\n\n\nRewrite the roll function below to roll a pair of weighted dice:\n\n\nroll &lt;- function() {\n  die &lt;- 1:6\n  dice &lt;- sample(die, size = 2, replace = TRUE)\n  sum(dice)\n}\nYou will need to add a prob argument to the sample function inside of roll. This argument should tell sample to sample the numbers one through five with probability 1/8 and the number 6 with probability 3/8.\nWhen you are finished, read on for a model answer.\nTo weight your dice, you need to add a prob argument with a vector of weights to sample, like this:\nroll &lt;- function() {\n  die &lt;- 1:6\n  dice &lt;- sample(die, size = 2, replace = TRUE, \n    prob = c(1/8, 1/8, 1/8, 1/8, 1/8, 3/8))\n  sum(dice)\n}\nThis will cause roll to pick 1 through 5 with probability 1/8 and 6 with probability 3/8.\nOverwrite your previous version of roll with the new function (by running the previous code snippet in your command line). Then visualize the new long-term behavior of your dice. I’ve put the results in Figure 2.5 next to our original results:\nrolls &lt;- replicate(10000, roll())\nqplot(rolls, binwidth = 1)\nThis confirms that we’ve effectively weighted the dice. High numbers occur much more often than low numbers. The remarkable thing is that this behavior will only be apparent when you examine long-term frequencies. On any single roll, the dice will appear to behave randomly. This is great news if you play Settlers of Catan (just tell your friends you lost the dice), but it should be disturbing if you analyze data, because it means that bias can easily occur without anyone noticing it in the short run.\n\n\n\nFigure 2.5: The dice are now clearly biased towards high numbers, since high sums occur much more often than low sums.\n\n\n\n\n2.3.2 Getting More Help\nR also comes with a super active community of users that you can turn to for help on the R-help mailing list. You can email the list with questions, but there’s a great chance that your question has already been answered. Find out by searching the archives.\nEven better than the R-help list is Stack Overflow, a website that allows programmers to answer questions and users to rank answers based on helpfulness. Personally, I find the Stack Overflow format to be more user-friendly than the R-help email list (and the respondents to be more human friendly). You can submit your own question or search through Stack Overflow’s previously answered questions related to R. There are over 30,000.\nBest of all is community.rstudio.com, a friendly, inclusive place to share questions related to R. community.rstudio.com is a very active forum focused on R. Don’t be surprised if you ask a question about an R package, and the author of the package shows up to answer.\nFor all of the R help list, Stack Overflow, and community.rstudio.com, you’re more likely to get a useful answer if you provide a reproducible example with your question. This means pasting in a short snippet of code that users can run to arrive at the bug or question you have in mind."
  },
  {
    "objectID": "packages.html#summary",
    "href": "packages.html#summary",
    "title": "2  Packages and Help Pages",
    "section": "2.4 Summary",
    "text": "2.4 Summary\nR’s packages and help pages can make you a more productive programmer. You saw in The Very Basics that R gives you the power to write your own functions that do specific things, but often the function that you want to write will already exist in an R package. Professors, programmers, and scientists have developed over 13,000 packages for you to use, which can save you valuable programming time. To use a package, you need to install it to your computer once with install.packages, and then load it into each new R session with library.\nR’s help pages will help you master the functions that appear in R and its packages. Each function and data set in R has its own help page. Although help pages often contain advanced content, they also contain valuable clues and examples that can help you learn how to use a function.\nYou have now seen enough of R to learn by doing, which is the best way to learn R. You can make your own R commands, run them, and get help when you need to understand something that I have not explained. I encourage you to experiment with your own ideas in R as you read through the next two projects."
  },
  {
    "objectID": "packages.html#project-1-wrap-up",
    "href": "packages.html#project-1-wrap-up",
    "title": "2  Packages and Help Pages",
    "section": "2.5 Project 1 Wrap-up",
    "text": "2.5 Project 1 Wrap-up\nYou’ve done more in this project than enable fraud and gambling; you’ve also learned how to speak to your computer in the language of R. R is a language like English, Spanish, or German, except R helps you talk to computers, not humans.\nYou’ve met the nouns of the R language, objects. And hopefully you guessed that functions are the verbs (I suppose function arguments would be the adverbs). When you combine functions and objects, you express a complete thought. By stringing thoughts together in a logical sequence, you can build eloquent, even artistic statements. In that respect, R is not that different than any other language.\nR shares another characteristic of human languages: you won’t feel very comfortable speaking R until you build up a vocabulary of R commands to use. Fortunately, you don’t have to be bashful. Your computer will be the only one to “hear” you speak R. Your computer is not very forgiving, but it also doesn’t judge. Not that you need to worry; you’ll broaden your R vocabulary tremendously between here and the end of the book.\nNow that you can use R, it is time to become an expert at using R to do data science. The foundation of data science is the ability to store large amounts of data and recall values on demand. From this, all else follows—manipulating data, visualizing data, modeling data, and more. However, you cannot easily store a data set in your mind by memorizing it. Nor can you easily store a data set on paper by writing it down. The only efficient way to store large amounts of data is with a computer. In fact, computers are so efficient that their development over the last three decades has completely changed the type of data we can accumulate and the methods we can use to analyze it. In short, computer data storage has driven the revolution in science that we call data science.\nProject 2: Playing Cards will make you part of this revolution by teaching you how to use R to store data sets in your computer’s memory and how to retrieve and manipulate data once it’s there."
  },
  {
    "objectID": "cards.html",
    "href": "cards.html",
    "title": "Project 2: Playing Cards",
    "section": "",
    "text": "This project–which spans the next four chapters–will teach you how to store, retrieve, and change data values in your computer’s memory. These skills will help you save and manage data without accumulating errors. In the project, you’ll design a deck of playing cards that you can shuffle and deal from. Best of all, the deck will remember which cards have been dealt–just like a real deck. You can use the deck to play card games, tell fortunes, and test card-counting strategies.\nAlong the way, you will learn how to:\n\nSave new types of data, like character strings and logical values\nSave a data set as a vector, matrix, array, list, or data frame\nLoad and save your own data sets with R\nExtract individual values from a data set\nChange individual values within a data set\nWrite logical tests\nUse R’s missing-value symbol, NA\n\nTo keep the project simple, I’ve divided it into four tasks. Each task will teach you a new skill for managing data with R:\nTask 1: build the deck\nIn R Objects, you will design and build a virtual deck of playing cards. This will be a complete data set, just like the ones you will use as a data scientist. You’ll need to know how to use R’s data types and data structures to make this work.\nTask 2: write functions that deal and shuffle\nNext, in R Notation, you will write two functions to use with the deck. One function will deal cards from the deck, and the other will reshuffle the deck. To write these functions, you’ll need to know how to extract values from a data set with R.\nTask 3: change the point system to suit your game\nIn Modifying Values, you will use R’s notation system to change the point values of your cards to match the card games you may wish to play, like war, hearts, or blackjack. This will help you change values in place in existing data sets.\nTask 4: manage the state of the deck\nFinally, in Environments, you will make sure that your deck remembers which cards it has dealt. This is an advanced task, and it will introduce R’s environment system and scoping rules. To do it successfully, you will need to learn the minute details of how R looks up and uses the data that you have stored in your computer."
  },
  {
    "objectID": "objects.html#atomic-vectors",
    "href": "objects.html#atomic-vectors",
    "title": "3  R Objects",
    "section": "3.1 Atomic Vectors",
    "text": "3.1 Atomic Vectors\nAn atomic vector is just a simple vector of data. In fact, you’ve already made an atomic vector, your die object from Project 1: Weighted Dice. You can make an atomic vector by grouping some values of data together with c:\ndie &lt;- c(1, 2, 3, 4, 5, 6)\ndie\n## 1 2 3 4 5 6\n\nis.vector(die)\n##  TRUE\n\n\n\n\n\n\nis.vector\n\n\n\nis.vector tests whether an object is an atomic vector. It returns TRUE if the object is an atomic vector and FALSE otherwise.\n\n\nYou can also make an atomic vector with just one value. R saves single values as an atomic vector of length 1:\nfive &lt;- 5\nfive\n## 5\n\nis.vector(five)\n##  TRUE\n\nlength(five)\n## 1\nlength(die)\n## 6\n\n\n\n\n\n\nlength\n\n\n\nlength returns the length of an atomic vector.\n\n\nEach atomic vector stores its values as a one-dimensional vector, and each atomic vector can only store one type of data. You can save different types of data in R by using different types of atomic vectors. Altogether, R recognizes six basic types of atomic vectors: doubles, integers, characters, logicals, complex, and raw.\nTo create your card deck, you will need to use different types of atomic vectors to save different types of information (text and numbers). You can do this by using some simple conventions when you enter your data. For example, you can create an integer vector by including a capital L with your input. You can create a character vector by surrounding your input in quotation marks:\nint &lt;- 1L\ntext &lt;- \"ace\"\nEach type of atomic vector has its own convention (described below). R will recognize the convention and use it to create an atomic vector of the appropriate type. If you’d like to make atomic vectors that have more than one element in them, you can combine an element with the c function. Use the same convention with each element:\nint &lt;- c(1L, 5L)\ntext &lt;- c(\"ace\", \"hearts\")\nYou may wonder why R uses multiple types of vectors. Vector types help R behave as you would expect. For example, R will do math with atomic vectors that contain numbers, but not with atomic vectors that contain character strings:\nsum(int)\n## 6\n\nsum(text)\n## Error in sum(text) : invalid 'type' (character) of argument\nBut we’re getting ahead of ourselves! Get ready to say hello to the six types of atomic vectors in R.\n\n3.1.1 Doubles\nA double vector stores regular numbers. The numbers can be positive or negative, large or small, and have digits to the right of the decimal place or not. In general, R will save any number that you type in R as a double. So, for example, the die you made in Project 1: Weighted Dice was a double object:\ndie &lt;- c(1, 2, 3, 4, 5, 6)\ndie\n## 1 2 3 4 5 6\nYou’ll usually know what type of object you are working with in R (it will be obvious), but you can also ask R what type of object an object is with typeof. For example:\ntypeof(die)\n##  \"double\"\nSome R functions refer to doubles as “numerics,” and I will often do the same. Double is a computer science term. It refers to the specific number of bytes your computer uses to store a number, but I find “numeric” to be much more intuitive when doing data science.\n\n\n3.1.2 Integers\nInteger vectors store integers, numbers that can be written without a decimal component. As a data scientist, you won’t use the integer type very often because you can save integers as a double object.\nYou can specifically create an integer in R by typing a number followed by an uppercase L. For example:\nint &lt;- c(-1L, 2L, 4L)\nint\n## -1  2  4\n\ntypeof(int)\n## \"integer\"\nNote that R won’t save a number as an integer unless you include the L. Integer numbers without the L will be saved as doubles. The only difference between 4 and 4L is how R saves the number in your computer’s memory. Integers are defined more precisely in your computer’s memory than doubles (unless the integer is very large or small).\nWhy would you save your data as an integer instead of a double? Sometimes a difference in precision can have surprising effects. Your computer allocates 64 bits of memory to store each double in an R program. This allows a lot of precision, but some numbers cannot be expressed exactly in 64 bits, the equivalent of a sequence of 64 ones and zeroes. For example, the number \\(\\pi\\) contains an endless sequences of digits to the right of the decimal place. Your computer must round \\(\\pi\\) to something close to, but not exactly equal to \\(\\pi\\) to store \\(\\pi\\) in its memory. Many decimal numbers share a similar fate.\nAs a result, each double is accurate to about 16 significant digits. This introduces a little bit of error. In most cases, this rounding error will go unnoticed. However, in some situations, the rounding error can cause surprising results. For example, you may expect the result of the expression below to be zero, but it is not:\nsqrt(2)^2 - 2\n## 4.440892e-16\nThe square root of two cannot be expressed exactly in 16 significant digits. As a result, R has to round the quantity, and the expression resolves to something very close to—but not quite—zero.\nThese errors are known as floating-point errors, and doing arithmetic in these conditions is known as floating-point arithmetic. Floating-point arithmetic is not a feature of R; it is a feature of computer programming. Usually floating-point errors won’t be enough to ruin your day. Just keep in mind that they may be the cause of surprising results.\nYou can avoid floating-point errors by avoiding decimals and only using integers. However, this is not an option in most data-science situations. You cannot do much math with integers before you need a noninteger to express the result. Luckily, the errors caused by floating-point arithmetic are usually insignificant (and when they are not, they are easy to spot). As a result, you’ll generally use doubles instead of integers as a data scientist.\n\n\n3.1.3 Characters\nA character vector stores small pieces of text. You can create a character vector in R by typing a character or string of characters surrounded by quotes:\ntext &lt;- c(\"Hello\",  \"World\")\ntext\n##  \"Hello\"  \"World\"\n\ntypeof(text)\n## \"character\"\n\ntypeof(\"Hello\")\n## \"character\"\nThe individual elements of a character vector are known as strings. Note that a string can contain more than just letters. You can assemble a character string from numbers or symbols as well.\n\n\n\n\n\n\nExercise: Character or Number?\n\n\n\nCan you spot the difference between a character string and a number? Here’s a test: Which of these are character strings and which are numbers? 1, \"1\", \"one\".\n\n\n\"1\" and \"one\" are both character strings.\nCharacter strings can contain number characters, but that doesn’t make them numeric. They’re just strings that happen to have numbers in them. You can tell strings from real numbers because strings come surrounded by quotes. In fact, anything surrounded by quotes in R will be treated as a character string—no matter what appears between the quotes.\nIt is easy to confuse R objects with character strings. Why? Because both appear as pieces of text in R code. For example, x is the name of an R object named “x,” \"x\" is a character string that contains the character “x.” One is an object that contains raw data, the other is a piece of raw data itself.\nExpect an error whenever you forget your quotation marks; R will start looking for an object that probably does not exist.\n\n\n3.1.4 Logicals\nLogical vectors store TRUEs and FALSEs, R’s form of Boolean data. Logicals are very helpful for doing things like comparisons:\n3 &gt; 4\n## FALSE\nAny time you type TRUE or FALSE in capital letters (without quotation marks), R will treat your input as logical data. R also assumes that T and F are shorthand for TRUE and FALSE, unless they are defined elsewhere (e.g. T &lt;- 500). Since the meaning of T and F can change, its best to stick with TRUE and FALSE:\nlogic &lt;- c(TRUE, FALSE, TRUE)\nlogic\n##   TRUE FALSE  TRUE\n\ntypeof(logic)\n## \"logical\"\n\ntypeof(F)\n## \"logical\"\n\n\n3.1.5 Complex and Raw\nDoubles, integers, characters, and logicals are the most common types of atomic vectors in R, but R also recognizes two more types: complex and raw. It is doubtful that you will ever use these to analyze data, but here they are for the sake of thoroughness.\nComplex vectors store complex numbers. To create a complex vector, add an imaginary term to a number with i:\ncomp &lt;- c(1 + 1i, 1 + 2i, 1 + 3i)\ncomp\n## 1+1i 1+2i 1+3i\n\ntypeof(comp)\n## \"complex\"\nRaw vectors store raw bytes of data. Making raw vectors gets complicated, but you can make an empty raw vector of length n with raw(n). See the help page of raw for more options when working with this type of data:\nraw(3)\n## 00 00 00\n\ntypeof(raw(3))\n## \"raw\"\n\n\n\n\n\n\nExercise: Vector of Cards\n\n\n\nCreate an atomic vector that stores just the face names of the cards in a royal flush, for example, the ace of spades, king of spades, queen of spades, jack of spades, and ten of spades. The face name of the ace of spades would be “ace,” and “spades” is the suit.\nWhich type of vector will you use to save the names?\n\n\nA character vector is the most appropriate type of atomic vector in which to save card names. You can create one with the c function if you surround each name with quotation marks:\nhand &lt;- c(\"ace\", \"king\", \"queen\", \"jack\", \"ten\")\nhand\n## \"ace\"   \"king\"  \"queen\" \"jack\"  \"ten\"  \n\ntypeof(hand)\n## \"character\"\nThis creates a one-dimensional group of card names—great job! Now let’s make a more sophisticated data structure, a two-dimensional table of card names and suits. You can build a more sophisticated object from an atomic vector by giving it some attributes and assigning it a class."
  },
  {
    "objectID": "objects.html#sec-attributes",
    "href": "objects.html#sec-attributes",
    "title": "3  R Objects",
    "section": "3.2 Attributes",
    "text": "3.2 Attributes\nAn attribute is a piece of information that you can attach to an atomic vector (or any R object). The attribute won’t affect any of the values in the object, and it will not appear when you display your object. You can think of an attribute as “metadata”; it is just a convenient place to put information associated with an object. R will normally ignore this metadata, but some R functions will check for specific attributes. These functions may use the attributes to do special things with the data.\nYou can see which attributes an object has with attributes. attributes will return NULL if an object has no attributes. An atomic vector, like die, won’t have any attributes unless you give it some:\nattributes(die)\n## NULL\n\n\n\n\n\n\nNULL\n\n\n\nR uses NULL to represent the null set, an empty object. NULL is often returned by functions whose values are undefined. You can create a NULL object by typing NULL in capital letters.\n\n\n\n3.2.1 Names\nThe most common attributes to give an atomic vector are names, dimensions (dim), and classes. Each of these attributes has its own helper function that you can use to give attributes to an object. You can also use the helper functions to look up the value of these attributes for objects that already have them. For example, you can look up the value of the names attribute of die with names:\nnames(die)\n## NULL\nNULL means that die does not have a names attribute. You can give one to die by assigning a character vector to the output of names. The vector should include one name for each element in die:\nnames(die) &lt;- c(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\nNow die has a names attribute:\nnames(die)\n## \"one\"   \"two\"   \"three\" \"four\"  \"five\"  \"six\" \n\nattributes(die)\n## $names\n## [1] \"one\"   \"two\"   \"three\" \"four\"  \"five\"  \"six\"\nR will display the names above the elements of die whenever you look at the vector:\ndie\n##  one   two three  four  five   six \n##    1     2     3     4     5     6 \nHowever, the names won’t affect the actual values of the vector, nor will the names be affected when you manipulate the values of the vector:\ndie + 1\n##  one   two three  four  five   six \n##    2     3     4     5     6     7\nYou can also use names to change the names attribute or remove it all together. To change the names, assign a new set of labels to names:\nnames(die) &lt;- c(\"uno\", \"dos\", \"tres\", \"quatro\", \"cinco\", \"seis\")\ndie\n##   uno    dos   tres quatro  cinco   seis \n##     1      2      3      4      5      6 \nTo remove the names attribute, set it to NULL:\nnames(die) &lt;- NULL\ndie\n##  1 2 3 4 5 6\n\n\n3.2.2 Dim\nYou can transform an atomic vector into an n-dimensional array by giving it a dimensions attribute with dim. To do this, set the dim attribute to a numeric vector of length n. R will reorganize the elements of the vector into n dimensions. Each dimension will have as many rows (or columns, etc.) as the nth value of the dim vector. For example, you can reorganize die into a 2 × 3 matrix (which has 2 rows and 3 columns):\ndim(die) &lt;- c(2, 3)\ndie\n##      [,1] [,2] [,3]\n## [1,]    1    3    5\n## [2,]    2    4    6\nor a 3 × 2 matrix (which has 3 rows and 2 columns):\ndim(die) &lt;- c(3, 2)\ndie\n##      [,1] [,2]\n## [1,]    1    4\n## [2,]    2    5\n## [3,]    3    6\nor a 1 × 2 × 3 hypercube (which has 1 row, 2 columns, and 3 “slices”). This is a three-dimensional structure, but R will need to show it slice by slice by slice on your two-dimensional computer screen:\ndim(die) &lt;- c(1, 2, 3)\ndie\n## , , 1\n## \n##      [,1] [,2]\n## [1,]    1    2\n## \n## , , 2\n## \n##      [,1] [,2]\n## [1,]    3    4\n## \n## , , 3\n## \n##      [,1] [,2]\n## [1,]    5    6\nR will always use the first value in dim for the number of rows and the second value for the number of columns. In general, rows always come first in R operations that deal with both rows and columns.\nYou may notice that you don’t have much control over how R reorganizes the values into rows and columns. For example, R always fills up each matrix by columns, instead of by rows. If you’d like more control over this process, you can use one of R’s helper functions, matrix or array. They do the same thing as changing the dim attribute, but they provide extra arguments to customize the process."
  },
  {
    "objectID": "objects.html#matrices",
    "href": "objects.html#matrices",
    "title": "3  R Objects",
    "section": "3.3 Matrices",
    "text": "3.3 Matrices\nMatrices store values in a two-dimensional array, just like a matrix from linear algebra. To create one, first give matrix an atomic vector to reorganize into a matrix. Then, define how many rows should be in the matrix by setting the nrow argument to a number. matrix will organize your vector of values into a matrix with the specified number of rows. Alternatively, you can set the ncol argument, which tells R how many columns to include in the matrix:\nm &lt;- matrix(die, nrow = 2)\nm\n##      [,1] [,2] [,3]\n## [1,]    1    3    5\n## [2,]    2    4    6\nmatrix will fill up the matrix column by column by default, but you can fill the matrix row by row if you include the argument byrow = TRUE:\nm &lt;- matrix(die, nrow = 2, byrow = TRUE)\nm\n##      [,1] [,2] [,3]\n## [1,]    1    2    3\n## [2,]    4    5    6\nmatrix also has other default arguments that you can use to customize your matrix. You can read about them at matrix’s help page (accessible by ?matrix)."
  },
  {
    "objectID": "objects.html#arrays",
    "href": "objects.html#arrays",
    "title": "3  R Objects",
    "section": "3.4 Arrays",
    "text": "3.4 Arrays\nThe array function creates an n-dimensional array. For example, you could use array to sort values into a cube of three dimensions or a hypercube in 4, 5, or n dimensions. array is not as customizeable as matrix and basically does the same thing as setting the dim attribute. To use array, provide an atomic vector as the first argument, and a vector of dimensions as the second argument, now called dim:\nar &lt;- array(c(11:14, 21:24, 31:34), dim = c(2, 2, 3))\nar\n## , , 1\n## \n##      [,1] [,2]\n## [1,]   11   13\n## [2,]   12   14\n## \n## , , 2\n## \n##      [,1] [,2]\n## [1,]   21   23\n## [2,]   22   24\n## \n## , , 3\n## \n##      [,1] [,2]\n## [1,]   31   33\n## [2,]   32   34\n\n\n\n\n\n\nExercise: Make a Matrix\n\n\n\nCreate the following matrix, which stores the name and suit of every card in a royal flush.\n\n\n##      [,1]    [,2]    \n## [1,] \"ace\"   \"spades\"\n## [2,] \"king\"  \"spades\"\n## [3,] \"queen\" \"spades\"\n## [4,] \"jack\"  \"spades\"\n## [5,] \"ten\"   \"spades\"\nThere is more than one way to build this matrix, but in every case, you will need to start by making a character vector with 10 values. If you start with the following character vector, you can turn it into a matrix with any of the following three commands:\nhand1 &lt;- c(\"ace\", \"king\", \"queen\", \"jack\", \"ten\", \"spades\", \"spades\", \n  \"spades\", \"spades\", \"spades\")\n\nmatrix(hand1, nrow = 5)\nmatrix(hand1, ncol = 2)\ndim(hand1) &lt;- c(5, 2)\nYou can also start with a character vector that lists the cards in a slightly different order. In this case, you will need to ask R to fill the matrix row by row instead of column by column:\nhand2 &lt;- c(\"ace\", \"spades\", \"king\", \"spades\", \"queen\", \"spades\", \"jack\", \n  \"spades\", \"ten\", \"spades\")\n\nmatrix(hand2, nrow = 5, byrow = TRUE)\nmatrix(hand2, ncol = 2, byrow = TRUE)"
  },
  {
    "objectID": "objects.html#class",
    "href": "objects.html#class",
    "title": "3  R Objects",
    "section": "3.5 Class",
    "text": "3.5 Class\nNotice that changing the dimensions of your object will not change the type of the object, but it will change the object’s class attribute:\ndim(die) &lt;- c(2, 3)\ntypeof(die)\n##  \"double\"\n \nclass(die)\n##  \"matrix\"\nA matrix is a special case of an atomic vector. For example, the die matrix is a special case of a double vector. Every element in the matrix is still a double, but the elements have been arranged into a new structure. R added a class attribute to die when you changed its dimensions. This class describes die’s new format. Many R functions will specifically look for an object’s class attribute, and then handle the object in a predetermined way based on the attribute.\nNote that an object’s class attribute will not always appear when you run attributes; you may need to specifically search for it with class:\nattributes(die)\n## $dim\n## [1] 2 3\nYou can apply class to objects that do not have a class attribute. class will return a value based on the object’s atomic type. Notice that the “class” of a double is “numeric,” an odd deviation, but one I am thankful for. I think that the most important property of a double vector is that it contains numbers, a property that “numeric” makes obvious:\nclass(\"Hello\")\n##  \"character\"\n\nclass(5)\n##  \"numeric\"\nYou can also use class to set an object’s class attribute, but this is usually a bad idea. R will expect objects of a class to share certain traits, such as attributes, that your object may not possess. You’ll learn how to make and use your own classes in Project 3: Slot Machine.\n\n3.5.1 Dates and Times\nThe attribute system lets R represent more types of data than just doubles, integers, characters, logicals, complexes, and raws. The time looks like a character string when you display it, but its data type is actually \"double\", and its class is \"POSIXct\" \"POSIXt\" (it has two classes):\nnow &lt;- Sys.time()\nnow\n## \"2014-03-17 12:00:00 UTC\"\n\ntypeof(now)\n##  \"double\"\n\nclass(now)\n## \"POSIXct\" \"POSIXt\" \nPOSIXct is a widely used framework for representing dates and times. In the POSIXct framework, each time is represented by the number of seconds that have passed between the time and 12:00 AM January 1st 1970 (in the Universal Time Coordinated (UTC) zone). For example, the time above occurs 1,395,057,600 seconds after then. So in the POSIXct system, the time would be saved as 1395057600.\nR creates the time object by building a double vector with one element, 1395057600. You can see this vector by removing the class attribute of now, or by using the unclass function, which does the same thing:\nunclass(now)\n## 1395057600\nR then gives the double vector a class attribute that contains two classes, \"POSIXct\" and \"POSIXt\". This attribute alerts R functions that they are dealing with a POSIXct time, so they can treat it in a special way. For example, R functions will use the POSIXct standard to convert the time into a user-friendly character string before displaying it.\nYou can take advantage of this system by giving the POSIXct class to random R objects. For example, have you ever wondered what day it was a million seconds after 12:00 a.m. Jan. 1, 1970?\nmil &lt;- 1000000\nmil\n## 1e+06\n \nclass(mil) &lt;- c(\"POSIXct\", \"POSIXt\")\nmil\n## \"1970-01-12 13:46:40 UTC\"\nJan. 12, 1970. Yikes. A million seconds goes by faster than you would think. This conversion worked well because the POSIXct class does not rely on any additional attributes, but in general, forcing the class of an object is a bad idea.\nThere are many different classes of data in R and its packages, and new classes are invented every day. It would be difficult to learn about every class, but you do not have to. Most classes are only useful in specific situations. Since each class comes with its own help page, you can wait to learn about a class until you encounter it. However, there is one class of data that is so ubiquitous in R that you should learn about it alongside the atomic data types. That class is factors.\n\n\n3.5.2 Factors\nFactors are R’s way of storing categorical information, like ethnicity or eye color. Think of a factor as something like a gender; it can only have certain values (male or female), and these values may have their own idiosyncratic order (ladies first). This arrangement makes factors very useful for recording the treatment levels of a study and other categorical variables.\nTo make a factor, pass an atomic vector into the factor function. R will recode the data in the vector as integers and store the results in an integer vector. R will also add a levels attribute to the integer, which contains a set of labels for displaying the factor values, and a class attribute, which contains the class factor:\ngender &lt;- factor(c(\"male\", \"female\", \"female\", \"male\"))\n\ntypeof(gender)\n## \"integer\"\n\nattributes(gender)\n## $levels\n## [1] \"female\" \"male\"  \n## \n## $class\n## [1] \"factor\"\nYou can see exactly how R is storing your factor with unclass:\nunclass(gender)\n## [1] 2 1 1 2\n## attr(,\"levels\")\n## [1] \"female\" \"male\"  \nR uses the levels attribute when it displays the factor, as you will see. R will display each 1 as female, the first label in the levels vector, and each 2 as male, the second label. If the factor included 3s, they would be displayed as the third label, and so on:\ngender\n## male   female female male  \n## Levels: female male\nFactors make it easy to put categorical variables into a statistical model because the variables are already coded as numbers. However, factors can be confusing since they look like character strings but behave like integers.\nR will often try to convert character strings to factors when you load and create data. In general, you will have a smoother experience if you do not let R make factors until you ask for them. I’ll show you how to do this when we start reading in data.\nYou can convert a factor to a character string with the as.character function. R will retain the display version of the factor, not the integers stored in memory:\nas.character(gender)\n## \"male\"   \"female\" \"female\" \"male\"\nNow that you understand the possibilities provided by R’s atomic vectors, let’s make a more complicated type of playing card.\n\n\n\n\n\n\nExercise: Write a Card\n\n\n\nMany card games assign a numerical value to each card. For example, in blackjack, each face card is worth 10 points, each number card is worth between 2 and 10 points, and each ace is worth 1 or 11 points, depending on the final score.\nMake a virtual playing card by combining “ace,” “heart,” and 1 into a vector. What type of atomic vector will result? Check if you are right.\n\n\nYou may have guessed that this exercise would not go well. Each atomic vector can only store one type of data. As a result, R coerces all of your values to character strings:\ncard &lt;- c(\"ace\", \"hearts\", 1)\ncard\n## \"ace\"    \"hearts\" \"1\" \nThis will cause trouble if you want to do math with that point value, for example, to see who won your game of blackjack.\n\n\n\n\n\n\nData types in vectors\n\n\n\nIf you try to put multiple types of data into a vector, R will convert the elements to a single type of data.\n\n\nSince matrices and arrays are special cases of atomic vectors, they suffer from the same behavior. Each can only store one type of data.\nThis creates a couple of problems. First, many data sets contain multiple types of data. Simple programs like Excel and Numbers can save multiple types of data in the same data set, and you should hope that R can too. Don’t worry, it can.\nSecond, coercion is a common behavior in R, so you’ll want to know how it works."
  },
  {
    "objectID": "objects.html#coercion",
    "href": "objects.html#coercion",
    "title": "3  R Objects",
    "section": "3.6 Coercion",
    "text": "3.6 Coercion\nR’s coercion behavior may seem inconvenient, but it is not arbitrary. R always follows the same rules when it coerces data types. Once you are familiar with these rules, you can use R’s coercion behavior to do surprisingly useful things.\nSo how does R coerce data types? If a character string is present in an atomic vector, R will convert everything else in the vector to character strings. If a vector only contains logicals and numbers, R will convert the logicals to numbers; every TRUE becomes a 1, and every FALSE becomes a 0, as shown in Figure 3.1.\n\n\n\nFigure 3.1: R always uses the same rules to coerce data to a single type. If character strings are present, everything will be coerced to a character string. Otherwise, logicals are coerced to numerics.\n\n\nThis arrangement preserves information. It is easy to look at a character string and tell what information it used to contain. For example, you can easily spot the origins of \"TRUE\" and \"5\". You can also easily back-transform a vector of 1s and 0s to TRUEs and FALSEs.\nR uses the same coercion rules when you try to do math with logical values. So the following code:\nsum(c(TRUE, TRUE, FALSE, FALSE))\nwill become:\nsum(c(1, 1, 0, 0))\n## 2\nThis means that sum will count the number of TRUEs in a logical vector (and mean will calculate the proportion of TRUEs). Neat, huh?\nYou can explicitly ask R to convert data from one type to another with the as functions. R will convert the data whenever there is a sensible way to do so:\nas.character(1)\n## \"1\"\n\nas.logical(1)\n## TRUE\n\nas.numeric(FALSE)\n## 0\nYou now know how R coerces data types, but this won’t help you save a playing card. To do that, you will need to avoid coercion altogether. You can do this by using a new type of object, a list.\nBefore we look at lists, let’s address a question that might be on your mind.\nMany data sets contain multiple types of information. The inability of vectors, matrices, and arrays to store multiple data types seems like a major limitation. So why bother with them?\nIn some cases, using only a single type of data is a huge advantage. Vectors, matrices, and arrays make it very easy to do math on large sets of numbers because R knows that it can manipulate each value the same way. Operations with vectors, matrices, and arrays also tend to be fast because the objects are so simple to store in memory.\nIn other cases, allowing only a single type of data is not a disadvantage. Vectors are the most common data structure in R because they store variables very well. Each value in a variable measures the same property, so there’s no need to use different types of data."
  },
  {
    "objectID": "objects.html#lists",
    "href": "objects.html#lists",
    "title": "3  R Objects",
    "section": "3.7 Lists",
    "text": "3.7 Lists\nLists are like atomic vectors because they group data into a one-dimensional set. However, lists do not group together individual values; lists group together R objects, such as atomic vectors and other lists. For example, you can make a list that contains a numeric vector of length 31 in its first element, a character vector of length 1 in its second element, and a new list of length 2 in its third element. To do this, use the list function.\nlist creates a list the same way c creates a vector. Separate each element in the list with a comma:\nlist1 &lt;- list(100:130, \"R\", list(TRUE, FALSE))\nlist1\n## [[1]]\n## [1] 100 101 102 103 104 105 106 107 108 109 110 111 112\n## [14] 113 114 115 116 117 118 119 120 121 122 123 124 125\n## [27] 126 127 128 129 130\n## \n## [[2]]\n## [1] \"R\"\n##\n## [[3]]\n## [[3]][[1]]\n## [1] TRUE\n##\n## [[3]][[2]]\n## [1] FALSE\nI left the [1] notation in the output so you can see how it changes for lists. The double-bracketed indexes tell you which element of the list is being displayed. The single-bracket indexes tell you which subelement of an element is being displayed. For example, 100 is the first subelement of the first element in the list. \"R\" is the first sub-element of the second element. This two-system notation arises because each element of a list can be any R object, including a new vector (or list) with its own indexes.\nLists are a basic type of object in R, on par with atomic vectors. Like atomic vectors, they are used as building blocks to create many more spohisticated types of R objects.\nAs you can imagine, the structure of lists can become quite complicated, but this flexibility makes lists a useful all-purpose storage tool in R: you can group together anything with a list.\nHowever, not every list needs to be complicated. You can store a playing card in a very simple list.\n\n\n\n\n\n\nExercise: Use a List to Make a Card\n\n\n\nUse a list to store a single playing card, like the ace of hearts, which has a point value of one. The list should save the face of the card, the suit, and the point value in separate elements.\n\n\nYou can create your card like this. In the following example, the first element of the list is a character vector (of length 1). The second element is also a character vector, and the third element is a numeric vector:\ncard &lt;- list(\"ace\", \"hearts\", 1)\ncard\n## [[1]]\n## [1] \"ace\"\n##\n## [[2]]\n## [1] \"hearts\"\n##\n## [[3]]\n## [1] 1\nYou can also use a list to store a whole deck of playing cards. Since you can save a single playing card as a list, you can save a deck of playing cards as a list of 52 sublists (one for each card). But let’s not bother—there’s a much cleaner way to do the same thing. You can use a special class of list, known as a data frame."
  },
  {
    "objectID": "objects.html#data-frames",
    "href": "objects.html#data-frames",
    "title": "3  R Objects",
    "section": "3.8 Data Frames",
    "text": "3.8 Data Frames\nData frames are the two-dimensional version of a list. They are far and away the most useful storage structure for data analysis, and they provide an ideal way to store an entire deck of cards. You can think of a data frame as R’s equivalent to the Excel spreadsheet because it stores data in a similar format.\nData frames group vectors together into a two-dimensional table. Each vector becomes a column in the table. As a result, each column of a data frame can contain a different type of data; but within a column, every cell must be the same type of data, as in Figure 3.2.\n\n\n\nFigure 3.2: Data frames store data as a sequence of columns. Each column can be a different data type. Every column in a data frame must be the same length.\n\n\nCreating a data frame by hand takes a lot of typing, but you can do it (if you like) with the data.frame function. Give data.frame any number of vectors, each separated with a comma. Each vector should be set equal to a name that describes the vector. data.frame will turn each vector into a column of the new data frame:\ndf &lt;- data.frame(face = c(\"ace\", \"two\", \"six\"),  \n  suit = c(\"clubs\", \"clubs\", \"clubs\"), value = c(1, 2, 3))\ndf\n## face  suit value\n##  ace clubs     1\n##  two clubs     2\n##  six clubs     3\nYou’ll need to make sure that each vector is the same length (or can be made so with R’s recycling rules; see Figure 1.4, as data frames cannot combine columns of different lengths.\nIn the previous code, I named the arguments in data.frame face, suit, and value, but you can name the arguments whatever you like. data.frame will use your argument names to label the columns of the data frame.\n\n\n\n\n\n\nNames\n\n\n\nYou can also give names to a list or vector when you create one of these objects. Use the same syntax as with data.frame:\nlist(face = \"ace\", suit = \"hearts\", value = 1)\nc(face = \"ace\", suit = \"hearts\", value = \"one\")\nThe names will be stored in the object’s names attribute.\n\n\nIf you look at the type of a data frame, you will see that it is a list. In fact, each data frame is a list with class data.frame. You can see what types of objects are grouped together by a list (or data frame) with the str function:\ntypeof(df)\n## \"list\"\n\nclass(df)\n## \"data.frame\"\n\nstr(df)\n## 'data.frame':    3 obs. of  3 variables:\n##  $ face : Factor w/ 3 levels \"ace\",\"six\",\"two\": 1 3 2\n##  $ suit : Factor w/ 1 level \"clubs\": 1 1 1\n##  $ value: num  1 2 3\nNotice that R saved your character strings as factors. I told you that R likes factors! It is not a very big deal here, but you can prevent this behavior by adding the argument stringsAsFactors = FALSE to data.frame:\ndf &lt;- data.frame(face = c(\"ace\", \"two\", \"six\"),  \n  suit = c(\"clubs\", \"clubs\", \"clubs\"), value = c(1, 2, 3),\n  stringsAsFactors = FALSE)\nA data frame is a great way to build an entire deck of cards. You can make each row in the data frame a playing card, and each column a type of value—each with its own appropriate data type. The data frame would look something like this:\n##   face     suit value\n##   king   spades    13\n##  queen   spades    12\n##   jack   spades    11\n##    ten   spades    10\n##   nine   spades     9\n##  eight   spades     8\n##  seven   spades     7\n##    six   spades     6\n##   five   spades     5\n##   four   spades     4\n##  three   spades     3\n##    two   spades     2\n##    ace   spades     1\n##   king    clubs    13\n##  queen    clubs    12\n##   jack    clubs    11\n##    ten    clubs    10\n##   ... and so on.\nYou could create this data frame with data.frame, but look at the typing involved! You need to write three vectors, each with 52 elements:\ndeck &lt;- data.frame(\n  face = c(\"king\", \"queen\", \"jack\", \"ten\", \"nine\", \"eight\", \"seven\", \"six\",\n    \"five\", \"four\", \"three\", \"two\", \"ace\", \"king\", \"queen\", \"jack\", \"ten\", \n    \"nine\", \"eight\", \"seven\", \"six\", \"five\", \"four\", \"three\", \"two\", \"ace\", \n    \"king\", \"queen\", \"jack\", \"ten\", \"nine\", \"eight\", \"seven\", \"six\", \"five\", \n    \"four\", \"three\", \"two\", \"ace\", \"king\", \"queen\", \"jack\", \"ten\", \"nine\", \n    \"eight\", \"seven\", \"six\", \"five\", \"four\", \"three\", \"two\", \"ace\"),  \n  suit = c(\"spades\", \"spades\", \"spades\", \"spades\", \"spades\", \"spades\", \n    \"spades\", \"spades\", \"spades\", \"spades\", \"spades\", \"spades\", \"spades\", \n    \"clubs\", \"clubs\", \"clubs\", \"clubs\", \"clubs\", \"clubs\", \"clubs\", \"clubs\", \n    \"clubs\", \"clubs\", \"clubs\", \"clubs\", \"clubs\", \"diamonds\", \"diamonds\", \n    \"diamonds\", \"diamonds\", \"diamonds\", \"diamonds\", \"diamonds\", \"diamonds\", \n    \"diamonds\", \"diamonds\", \"diamonds\", \"diamonds\", \"diamonds\", \"hearts\", \n    \"hearts\", \"hearts\", \"hearts\", \"hearts\", \"hearts\", \"hearts\", \"hearts\", \n    \"hearts\", \"hearts\", \"hearts\", \"hearts\", \"hearts\"), \n  value = c(13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 13, 12, 11, 10, 9, 8, \n    7, 6, 5, 4, 3, 2, 1, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 13, 12, 11, \n    10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n)\nYou should avoid typing large data sets in by hand whenever possible. Typing invites typos and errors, not to mention RSI. It is always better to acquire large data sets as a computer file. You can then ask R to read the file and store the contents as an object.\nI’ve created a file for you to load that contains a data frame of playing-card information, so don’t worry about typing in the code. Instead, turn your attention toward loading data into R."
  },
  {
    "objectID": "objects.html#sec-loading-data",
    "href": "objects.html#sec-loading-data",
    "title": "3  R Objects",
    "section": "3.9 Loading Data",
    "text": "3.9 Loading Data\nYou can load the deck data frame from the file deck.csv. Please take a moment to download the file before reading on. Visit the website, click “Download Zip,” and then unzip and open the folder that your web browser downloads. deck.csv will be inside.\ndeck.csv is a comma-separated values file, or CSV for short. CSVs are plain-text files, which means you can open them in a text editor (as well as many other programs). If you open desk.csv, you’ll notice that it contains a table of data that looks like the following table. Each row of the table is saved on its own line, and a comma is used to separate the cells within each row. Every CSV file shares this basic format:\n\"face\",\"suit,\"value\"\n\"king\",\"spades\",13\n\"queen\",\"spades,12\n\"jack\",\"spades,11\n\"ten\",\"spades,10\n\"nine\",\"spades,9\n... and so on.\nMost data-science applications can open plain-text files and export data as plain-text files. This makes plain-text files a sort of lingua franca for data science.\nTo load a plain-text file into R, click the Import Dataset icon in RStudio, shown in Figure 3.3. Then select “From text file.”\n\n\n\nFigure 3.3: You can import data from plain-text files with RStudio’s Import Dataset.\n\n\nRStudio will ask you to select the file you want to import, then it will open a wizard to help you import the data, as in Figure 3.4. Use the wizard to tell RStudio what name to give the data set. You can also use the wizard to tell RStudio which character the data set uses as a separator, which character it uses to represent decimals (usually a period in the United States and a comma in Europe), and whether or not the data set comes with a row of column names (known as a header). To help you out, the wizard shows you what the raw file looks like, as well as what your loaded data will look like based on the input settings.\nYou can also unclick the box “Strings as factors” in the wizard. I recommend doing this. If you do, R will load all of your character strings as character strings. If you do not, R will convert them to factors.\n\n\n\nFigure 3.4: RStudio’s import wizard.\n\n\nOnce everything looks right, click Import. RStudio will read in the data and save it to a data frame. RStudio will also open a data viewer, so you can see your new data in a spreadsheet format. This is a good way to check that everything came through as expected. If all worked well, your file should appear in a View tab of RStudio, like in Figure 3.5. You can examine the data frame in the console with head(deck).\n\n\n\n\n\n\nOnline data\n\n\n\nYou can load a plain-text file straight from the Internet by clicking the “From Web URL…” option under Import Dataset. The file will need to have its own URL, and you will need to be connected.\n\n\n\n\n\nFigure 3.5: When you import a data set, RStudio will save the data to a data frame and then display the data frame in a View tab. You can open any data frame in a View tab at any time with the View function.\n\n\nNow it is your turn. Download deck.csv and import it into RStudio. Be sure to save the output to an R object called deck: you’ll use it in the next few chapters. If everything goes correctly, the first few lines of your data frame should look like this:\nhead(deck)\n##  face   suit value\n##  king spades    13\n## queen spades    12\n##  jack spades    11\n##   ten spades    10\n##  nine spades     9\n## eight spades     8\n\n\n\n\n\n\nNote\n\n\n\nhead and tail are two functions that provide an easy way to peek at large data sets. head will return just the first six rows of the data set, and tail will return just the last six rows. To see a different number of rows, give head or tails a second argument, the number of rows you would like to view, for example, head(deck, 10).\n\n\nR can open many types of files—not just CSVs. Visit Loading and Saving Data in R to learn how to open other common types of files in R."
  },
  {
    "objectID": "objects.html#saving-data",
    "href": "objects.html#saving-data",
    "title": "3  R Objects",
    "section": "3.10 Saving Data",
    "text": "3.10 Saving Data\nBefore we go any further, let’s save a copy of deck as a new .csv file. That way you can email it to a colleague, store it on a thumb drive, or open it in a different program. You can save any data frame in R to a .csv file with the command write.csv. To save deck, run:\nwrite.csv(deck, file = \"cards.csv\", row.names = FALSE)\nR will turn your data frame into a plain-text file with the comma-separated values format and save the file to your working directory. To see where your working directory is, run getwd(). To change the location of your working directory, visit Session &gt; Set Working Directory &gt; Choose Directory in the RStudio menu bar.\nYou can customize the save process with write.csv’s large set of optional arguments (see ?write.csv for details). However, there are three arguments that you should use every time you run write.csv.\nFirst, you should give write.csv the name of the data frame that you wish to save. Next, you should provide a file name to give your file. R will take this name quite literally, so be sure to provide an extension.\nFinally, you should add the argument row.names = FALSE. This will prevent R from adding a column of numbers at the start of your data frame. These numbers will identify your rows from 1 to 52, but it is unlikely that whatever program you open cards.csv in will understand the row name system. More than likely, the program will assume that the row names are the first column of data in your data frame. In fact, this is exactly what R will assume if you reopen cards.csv. If you save and open cards.csv several times in R, you’ll notice duplicate columns of row numbers forming at the start of your data frame. I can’t explain why R does this, but I can explain how to avoid it: use row.names = FALSE whenever you save data with write.csv.\nFor more details about saving files, including how to compress saved files and how to save files in other formats, see Loading and Saving Data in R.\nGood work. You now have a virtual deck of cards to work with. Take a breather, and when you come back, we’ll start writing some functions to use on your deck."
  },
  {
    "objectID": "objects.html#summary",
    "href": "objects.html#summary",
    "title": "3  R Objects",
    "section": "3.11 Summary",
    "text": "3.11 Summary\nYou can save data in R with five different objects, which let you store different types of values in different types of relationships, as in Figure 3.6. Of these objects, data frames are by far the most useful for data science. Data frames store one of the most common forms of data used in data science, tabular data.\n\n\n\nFigure 3.6: R’s most common data structures are vectors, matrices, arrays, lists, and data frames.\n\n\nYou can load tabular data into a data frame with RStudio’s Import Dataset button—so long as the data is saved as a plain-text file. This requirement is not as limiting as it sounds. Most software programs can export data as a plain-text file. So if you have an Excel file (for example) you can open the file in Excel and export the data as a CSV to use with R. In fact, opening a file in its original program is good practice. Excel files use metadata, like sheets and formulas, that help Excel work with the file. R can try to extract raw data from the file, but it won’t be as good at doing this as Microsoft Excel is. No program is better at converting Excel files than Excel. Similarly, no program is better at converting SAS Xport files than SAS, and so on.\nHowever, you may find yourself with a program-specific file, but not the program that created it. You wouldn’t want to buy a multi-thousand-dollar SAS license just to open a SAS file. Thankfully R can open many types of files, including files from other programs and databases. R even has its own program-specific formats that can help you save memory and time if you know that you will be working entirely in R. If you’d like to know more about all of your options for loading and saving data in R, see Loading and Saving Data in R.\nR Notation will build upon the skills you learned in this chapter. Here, you learned how to store data in R. In R Notation, you will learn how to access values once they’ve been stored. You’ll also write two functions that will let you start using your deck, a shuffle function and a deal function."
  },
  {
    "objectID": "notation.html#selecting-values",
    "href": "notation.html#selecting-values",
    "title": "4  R Notation",
    "section": "4.1 Selecting Values",
    "text": "4.1 Selecting Values\nR has a notation system that lets you extract values from R objects. To extract a value or set of values from a data frame, write the data frame’s name followed by a pair of hard brackets:\ndeck[ , ]\nBetween the brackets will go two indexes separated by a comma. The indexes tell R which values to return. R will use the first index to subset the rows of the data frame and the second index to subset the columns.\nYou have a choice when it comes to writing indexes. There are six different ways to write an index for R, and each does something slightly different. They are all very simple and quite handy, so let’s take a look at each of them. You can create indexes with:\n\nPositive integers\nNegative integers\nZero\nBlank spaces\nLogical values\nNames\n\nThe simplest of these to use is positive integers.\n\n4.1.1 Positive Integers\nR treats positive integers just like ij notation in linear algebra: as illustrated in Figure 4.1, deck[i,j] will return the value of deck that is in the ith row and the jth column. Notice that i and j only need to be integers in the mathematical sense. They can be saved as numerics in R\nhead(deck)\n##  face   suit value\n##  king spades    13\n## queen spades    12\n##  jack spades    11\n##   ten spades    10\n##  nine spades     9\n## eight spades     8\n\ndeck[1, 1]\n## \"king\"\nTo extract more than one value, use a vector of positive integers. For example, you can return the first row of deck with deck[1, c(1, 2, 3)] or deck[1, 1:3]:\ndeck[1, c(1, 2, 3)]\n## face   suit value\n## king spades    13\nR will return the values of deck that are in both the first row and the first, second, and third columns. Note that R won’t actually remove these values from deck. R will give you a new set of values which are copies of the original values. You can then save this new set to an R object with R’s assignment operator:\nnew &lt;- deck[1, c(1, 2, 3)]\nnew\n## face   suit value\n## king spades    13\n\n\n\n\n\n\nRepetition\n\n\n\nIf you repeat a number in your index, R will return the corresponding value(s) more than once in your “subset.” This code will return the first row of deck twice:\ndeck[c(1, 1), c(1, 2, 3)]\n## face   suit value\n## king spades    13\n## king spades    13\n\n\n\n\n\nFigure 4.1: R uses the ij notation system of linear algebra. The commands in this figure will return the shaded values.\n\n\nR’s notation system is not limited to data frames. You can use the same syntax to select values in any R object, as long as you supply one index for each dimension of the object. So, for example, you can subset a vector (which has one dimension) with a single index:\nvec &lt;- c(6, 1, 3, 6, 10, 5)\nvec[1:3]\n## 6 1 3\n\n\n\n\n\n\nIndexing begins at 1\n\n\n\nIn some programming languages, indexing begins with 0. This means that 0 returns the first element of a vector, 1 returns the second element, and so on.\nThis isn’t the case with R. Indexing in R behaves just like indexing in linear algebra. The first element is always indexed by 1. Why is R different? Maybe because it was written for mathematicians. Those of us who learned indexing from a linear algebra course wonder why computers programmers start with 0.\n\n\n\n\n\n\n\n\ndrop = FALSE\n\n\n\nIf you select two or more columns from a data frame, R will return a new data frame:\ndeck[1:2, 1:2]\n##  face   suit\n##  king spades\n## queen spades\nHowever, if you select a single column, R will return a vector:\ndeck[1:2, 1]\n##  \"king\"  \"queen\"\nIf you would prefer a data frame instead, you can add the optional argument drop = FALSE between the brackets:\ndeck[1:2, 1, drop = FALSE]\n##  face\n##  king\n## queen\nThis method also works for selecting a single column from a matrix or an array.\n\n\n\n\n4.1.2 Negative Integers\nNegative integers do the exact opposite of positive integers when indexing. R will return every element except the elements in a negative index. For example, deck[-1, 1:3] will return everything but the first row of deck. deck[-(2:52), 1:3] will return the first row (and exclude everything else):\ndeck[-(2:52), 1:3]\n## face   suit value\n## king spades    13\nNegative integers are a more efficient way to subset than positive integers if you want to include the majority of a data frame’s rows or columns.\nR will return an error if you try to pair a negative integer with a positive integer in the same index:\ndeck[c(-1, 1), 1]\n## Error in xj[i] : only 0's may be mixed with negative subscripts\nHowever, you can use both negative and positive integers to subset an object if you use them in different indexes (e.g., if you use one in the rows index and one in the columns index, like deck[-1, 1]).\n\n\n4.1.3 Zero\nWhat would happen if you used zero as an index? Zero is neither a positive integer nor a negative integer, but R will still use it to do a type of subsetting. R will return nothing from a dimension when you use zero as an index. This creates an empty object:\ndeck[0, 0]\n## data frame with 0 columns and 0 rows\nTo be honest, indexing with zero is not very helpful.\n\n\n4.1.4 Blank Spaces\nYou can use a blank space to tell R to extract every value in a dimension. This lets you subset an object on one dimension but not the others, which is useful for extracting entire rows or columns from a data frame:\ndeck[1, ]\n## face   suit value\n## king spades    13\n\n\n4.1.5 Logical Values\nIf you supply a vector of TRUEs and FALSEs as your index, R will match each TRUE and FALSE to a row in your data frame (or a column depending on where you place the index). R will then return each row that corresponds to a TRUE, Figure 4.2.\nIt may help to imagine R reading through the data frame and asking, “Should I return the _i_th row of the data structure?” and then consulting the _i_th value of the index for its answer. For this system to work, your vector must be as long as the dimension you are trying to subset:\ndeck[1, c(TRUE, TRUE, FALSE)]\n## face   suit \n## king spades\n\nrows &lt;- c(TRUE, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, \n  F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, \n  F, F, F, F, F, F, F, F, F, F, F, F, F, F)\ndeck[rows, ]\n## face   suit value\n## king spades    13\n\n\n\nFigure 4.2: You can use vectors of TRUEs and FALSEs to tell R exactly which values you want to extract and which you do not. The command would return just the numbers 1, 6, and 5.\n\n\nThis system may seem odd—who wants to type so many TRUEs and FALSEs?—but it will become very powerful in Modifying Values.\n\n\n4.1.6 Names\nFinally, you can ask for the elements you want by name—if your object has names (see Names). This is a common way to extract the columns of a data frame, since columns almost always have names:\ndeck[1, c(\"face\", \"suit\", \"value\")]\n## face   suit value\n## king spades    13\n\n# the entire value column\ndeck[ , \"value\"]\n##  13 12 11 10  9  8  7  6  5  4  3  2  1 13 12 11 10  9  8\n##  7  6  5  4  3  2  1 13 12 11 10  9  8  7  6  5  4  3  2\n##  1 13 12 11 10  9  8  7  6  5  4  3  2  1"
  },
  {
    "objectID": "notation.html#deal-a-card",
    "href": "notation.html#deal-a-card",
    "title": "4  R Notation",
    "section": "4.2 Deal a Card",
    "text": "4.2 Deal a Card\nNow that you know the basics of R’s notation system, let’s put it to use.\n\n\n\n\n\n\nExercise: Deal a Card\n\n\n\nComplete the following code to make a function that returns the first row of a data frame:\ndeal &lt;- function(cards) {\n   # ?\n}\n\n\nYou can use any of the systems that return the first row of your data frame to write a deal function. I’ll use positive integers and blanks because I think they are easy to understand:\ndeal &lt;- function(cards) {\n  cards[1, ]\n}\nThe function does exactly what you want: it deals the top card from your data set. However, the function becomes less impressive if you run deal over and over again:\ndeal(deck)\n## face   suit value\n## king spades    13\n\ndeal(deck)\n## face   suit value\n## king spades    13\n\ndeal(deck)\n## face   suit value\n## king spades    13\ndeal always returns the king of spades because deck doesn’t know that we’ve dealt the card away. Hence, the king of spades stays where it is, at the top of the deck ready to be dealt again. This is a difficult problem to solve, and we will deal with it in Environments. In the meantime, you can fix the problem by shuffling your deck after every deal. Then a new card will always be at the top.\nShuffling is a temporary compromise: the probabilities at play in your deck will not match the probabilities that occur when you play a game with a single deck of cards. For example, there will still be a probability that the king of spades appears twice in a row. However, things are not as bad as they may seem. Most casinos use five or six decks at a time in card games to prevent card counting. The probabilities that you would encounter in those situations are very close to the ones we will create here."
  },
  {
    "objectID": "notation.html#shuffle-the-deck",
    "href": "notation.html#shuffle-the-deck",
    "title": "4  R Notation",
    "section": "4.3 Shuffle the Deck",
    "text": "4.3 Shuffle the Deck\nWhen you shuffle a real deck of cards, you randomly rearrange the order of the cards. In your virtual deck, each card is a row in a data frame. To shuffle the deck, you need to randomly reorder the rows in the data frame. Can this be done? You bet! And you already know everything you need to do it.\nThis may sound silly, but start by extracting every row in your data frame:\ndeck2 &lt;- deck[1:52, ]\n\nhead(deck2)\n##   face   suit value\n##   king spades    13\n##  queen spades    12\n##   jack spades    11\n##    ten spades    10\n##   nine spades     9\n##  eight spades     8\nWhat do you get? A new data frame whose order hasn’t changed at all. What if you asked R to extract the rows in a different order? For example, you could ask for row 2, then row 1, and then the rest of the cards:\ndeck3 &lt;- deck[c(2, 1, 3:52), ]\n\nhead(deck3)\n##   face   suit value\n##  queen spades    12\n##   king spades    13\n##   jack spades    11\n##    ten spades    10\n##   nine spades     9\n##  eight spades     8\nR complies. You’ll get all the rows back, and they’ll come in the order you ask for them. If you want the rows to come in a random order, then you need to sort the integers from 1 to 52 into a random order and use the results as a row index. How could you generate such a random collection of integers? With our friendly neighborhood sample function:\nrandom &lt;- sample(1:52, size = 52)\nrandom\n##  35 28 39  9 18 29 26 45 47 48 23 22 21 16 32 38  1 15 20\n##  11  2  4 14 49 34 25  8  6 10 41 46 17 33  5  7 44  3 27\n##  50 12 51 40 52 24 19 13 42 37 43 36 31 30\n\ndeck4 &lt;- deck[random, ]\nhead(deck4)\n##   face     suit value\n##   five diamonds     5\n##  queen diamonds    12\n##    ace diamonds     1\n##   five   spades     5\n##   nine    clubs     9\n##   jack diamonds    11\nNow the new set is truly shuffled. You’ll be finished once you wrap these steps into a function.\n\n\n\n\n\n\nExercise: Shuffle a Deck\n\n\n\nUse the preceding ideas to write a shuffle function. shuffle should take a data frame and return a shuffled copy of the data frame.\n\n\nYour shuffle function will look like the one that follows:\nshuffle &lt;- function(cards) { \n  random &lt;- sample(1:52, size = 52)\n  cards[random, ]\n}\nNice work! Now you can shuffle your cards between each deal:\ndeal(deck)\n## face   suit value\n## king spades    13\n\ndeck2 &lt;- shuffle(deck) \n\ndeal(deck2)\n## face  suit value\n## jack clubs    11"
  },
  {
    "objectID": "notation.html#dollar-signs-and-double-brackets",
    "href": "notation.html#dollar-signs-and-double-brackets",
    "title": "4  R Notation",
    "section": "4.4 Dollar Signs and Double Brackets",
    "text": "4.4 Dollar Signs and Double Brackets\nTwo types of object in R obey an optional second system of notation. You can extract values from data frames and lists with the $ syntax. You will encounter the $ syntax again and again as an R programmer, so let’s examine how it works.\nTo select a column from a data frame, write the data frame’s name and the column name separated by a $. Notice that no quotes should go around the column name:\ndeck$value\n## 13 12 11 10  9  8  7  6  5  4  3  2  1 13 12 11 10  9  8  7\n##  6  5  4  3  2  1 13 12 11 10  9  8  7  6  5  4  3  2  1 13\n## 12 11 10  9  8  7  6  5  4  3  2  1\nR will return all of the values in the column as a vector. This $ notation is incredibly useful because you will often store the variables of your data sets as columns in a data frame. From time to time, you’ll want to run a function like mean or median on the values in a variable. In R, these functions expect a vector of values as input, and deck$value delivers your data in just the right format:\nmean(deck$value)\n## 7\n\nmedian(deck$value)\n## 7\nYou can use the same $ notation with the elements of a list, if they have names. This notation has an advantage with lists, too. If you subset a list in the usual way, R will return a new list that has the elements you requested. This is true even if you only request a single element.\nTo see this, make a list:\nlst &lt;- list(numbers = c(1, 2), logical = TRUE, strings = c(\"a\", \"b\", \"c\"))\nlst\n## $numbers\n## [1] 1 2\n\n## $logical\n## [1] TRUE\n\n## $strings\n## [1] \"a\" \"b\" \"c\"\nAnd then subset it:\nlst[1]\n## $numbers\n## [1] 1 2\nThe result is a smaller list with one element. That element is the vector c(1, 2). This can be annoying because many R functions do not work with lists. For example, sum(lst[1]) will return an error. It would be horrible if once you stored a vector in a list, you could only ever get it back as a list:\nsum(lst[1])\n## Error in sum(lst[1]) : invalid 'type' (list) of argument\nWhen you use the $ notation, R will return the selected values as they are, with no list structure around them:\nlst$numbers\n## 1 2\nYou can then immediately feed the results to a function:\nsum(lst$numbers)\n## 3\nIf the elements in your list do not have names (or you do not wish to use the names), you can use two brackets, instead of one, to subset the list. This notation will do the same thing as the $ notation:\nlst[[1]]\n## 1 2\nIn other words, if you subset a list with single-bracket notation, R will return a smaller list. If you subset a list with double-bracket notation, R will return just the values that were inside an element of the list. You can combine this feature with any of R’s indexing methods:\nlst[\"numbers\"]\n## $numbers\n## [1] 1 2\n\nlst[[\"numbers\"]]\n## 1 2\nThis difference is subtle but important. In the R community, there is a popular, and helpful, way to think about it, Figure 4.3. Imagine that each list is a train and each element is a train car. When you use single brackets, R selects individual train cars and returns them as a new train. Each car keeps its contents, but those contents are still inside a train car (i.e., a list). When you use double brackets, R actually unloads the car and gives you back the contents.\n\n\n\nFigure 4.3: It can be helpful to think of your list as a train. Use single brackets to select train cars, double brackets to select the contents inside of a car.\n\n\n\n\n\n\n\n\nNever attach\n\n\n\nIn R’s early days, it became popular to use attach() on a data set once you had it loaded. Don’t do this! attach recreates a computing environment similar to those used in other statistics applications like Stata and SPSS, which crossover users liked. However, R is not Stata or SPSS. R is optimized to use the R computing environment, and running attach() can cause confusion with some R functions.\nWhat does attach() do? On the surface, attach saves you typing. If you attach the deck data set, you can refer to each of its variables by name; instead of typing deck$face, you can just type face. But typing isn’t bad. It gives you a chance to be explicit, and in computer programming, explicit is good. Attaching a data set creates the possibility that R will confuse two variable names. If this occurs within a function, you’re likely to get unusable results and an unhelpful error message to explain what happened.\n\n\nNow that you are an expert at retrieving values stored in R, let’s summarize what you’ve accomplished."
  },
  {
    "objectID": "notation.html#summary",
    "href": "notation.html#summary",
    "title": "4  R Notation",
    "section": "4.5 Summary",
    "text": "4.5 Summary\nYou have learned how to access values that have been stored in R. You can retrieve a copy of values that live inside a data frame and use the copies for new computations.\nIn fact, you can use R’s notation system to access values in any R object. To use it, write the name of an object followed by brackets and indexes. If your object is one-dimensional, like a vector, you only need to supply one index. If it is two-dimensional, like a data frame, you need to supply two indexes separated by a comma. And, if it is n-dimensional, you need to supply n indexes, each separated by a comma.\nIn Modifying Values, you’ll take this system a step further and learn how to change the actual values that are stored inside your data frame. This is all adding up to something special: complete control of your data. You can now store your data in your computer, retrieve individual values at will, and use your computer to perform correct calculations with those values.\nDoes this sound basic? It may be, but it is also powerful and essential for efficient data science. You no longer need to memorize everything in your head, nor worry about doing mental arithmetic wrong. This low-level control over your data is also a prerequisite for more efficient R programs, the subject of Project 3: Slot Machine."
  },
  {
    "objectID": "slots.html",
    "href": "slots.html",
    "title": "Project 3: Slot Machine",
    "section": "",
    "text": "Slot machines are the most popular game in modern casinos. If you’ve never seen one, a slot machine resembles an arcade game that has a lever on its side. For a small fee you can pull the lever, and the machine will generate a random combination of three symbols. If the correct combination appears, you can win a prize, maybe even the jackpot.\nSlot machines make fantastic profits for casinos because they offer a very low payout rate. In many games, such as Blackjack and Roulette, the odds are only slightly stacked in the casino’s favor. In the long run, the casino pays back 97 to 98 cents in prizes of every dollar that a gambler spends on these games. With slot machines, it is typical for a casino to only pay back 90 to 95 cents—and the casino keeps the rest. If this seems underhanded, keep in mind that slot machines are one of the most popular games at a casino; few people seem to mind. And if you consider that state lotteries have payout rates that are much closer to 50 cents on the dollar, slot machines don’t look that bad.\nIn this project, you will build a real, working slot machine modeled after some real life Video Lottery Terminals from Manitoba, Canada. The terminals were a source of scandal in the 1990s. You’ll get to the bottom of this scandal by writing a program that recreates the slot machines. You’ll then do some calculations and run some simulations that reveal the true payout rate of the machines.\nThis project will teach you how to write programs and run simulations in R. You will also learn how to:\n\nUse a practical strategy to design programs\nUse if and else statements to tell R what to do when\nCreate lookup tables to find values\nUse for, while, and repeat loops to automate repetitive operations\nUse S3 methods, R’s version of Object-Oriented Programming\nMeasure the speed of R code\nWrite fast, vectorized R code"
  },
  {
    "objectID": "programs.html#strategy",
    "href": "programs.html#strategy",
    "title": "5  Programs",
    "section": "5.1 Strategy",
    "text": "5.1 Strategy\nScoring slot-machine results is a complex task that will require a complex algorithm. You can make this, and other coding tasks, easier by using a simple strategy:\n\nBreak complex tasks into simple subtasks.\nUse concrete examples.\nDescribe your solutions in English, then convert them to R.\n\nLet’s start by looking at how you can divide a program into subtasks that are simple to work with.\nA program is a set of step-by-step instructions for your computer to follow. Taken together, these instructions may accomplish something very sophisticated. Taken apart, each individual step will likely be simple and straightforward.\nYou can make coding easier by identifying the individual steps or subtasks within your program. You can then work on each subtask separately. If a subtask seems complicated, try to divide it again into even subtasks that are even more simple. You can often reduce an R program into substasks so simple that each can be performed with a preexisting function.\nR programs contain two types of subtasks: sequential steps and parallel cases.\n\n5.1.1 Sequential Steps\nOne way to subdivide a program is into a series of sequential steps. The play function takes the approach, shown in Figure 5.1. First, it generates three symbols (step 1), then it displays them in the console window (step 2), and then it scores them (step 3):\nplay &lt;- function() {\n\n  # step 1: generate symbols\n  symbols &lt;- get_symbols()\n\n  # step 2: display the symbols\n  print(symbols)\n\n  # step 3: score the symbols\n  score(symbols)\n}\nTo have R execute steps in sequence, place the steps one after another in an R script or function body.\n\n\n\nFigure 5.1: The play function uses a series of steps.\n\n\n\n\n5.1.2 Parallel Cases\nAnother way to divide a task is to spot groups of similar cases within the task. Some tasks require different algorithms for different groups of input. If you can identify those groups, you can work out their algorithms one at a time.\nFor example, score will need to calculate the prize one way if symbols contains three of a kind (In that case, score will need to match the common symbol to a prize). score will need to calculate the prize a second way if the symbols are all bars (In that case, score can just assign a prize of $5). And, finally, score will need to calculate the prize in a third way if the symbols do not contain three of a kind or all bars (In that case, score must count the number of cherries present). score will never use all three of these algorithms at once; it will always choose just one algorithm to run based on the combination of symbols.\nDiamonds complicate all of this because diamonds can be treated as wild cards. Let’s ignore that for now and focus on the simpler case where diamonds double the prize but are not wilds. score can double the prize as necessary after it runs one of the following algorithms, as shown in Figure 5.2.\nAdding the score cases to the play steps reveals a strategy for the complete slot machine program, as shown in Figure 5.3.\nWe’ve already solved the first few steps in this strategy. Our program can get three slot machine symbols with the get_symbols function. Then it can display the symbols with the print function. Now let’s examine how the program can handle the parallel score cases.\n\n\n\nFigure 5.2: The score function must distinguish between parallel cases.\n\n\n\n\n\nFigure 5.3: The complete slot machine simulation will involve subtasks that are arranged both in series and in parallel."
  },
  {
    "objectID": "programs.html#if-statements",
    "href": "programs.html#if-statements",
    "title": "5  Programs",
    "section": "5.2 if Statements",
    "text": "5.2 if Statements\nLinking cases together in parallel requires a bit of structure; your program faces a fork in the road whenever it must choose between cases. You can help the program navigate this fork with an if statement.\nAn if statement tells R to do a certain task for a certain case. In English you would say something like, “If this is true, do that.” In R, you would say:\nif (this) {\n  that\n}\nThe this object should be a logical test or an R expression that evaluates to a single TRUE or FALSE. If this evaluates to TRUE, R will run all of the code that appears between the braces that follow the if statement (i.e., between the { and } symbols). If this evaluates to FALSE, R will skip the code between the braces without running it.\nFor example, you could write an if statement that ensures some object, num, is positive:\nif (num &lt; 0) {\n  num &lt;- num * -1\n}\nIf num &lt; 0 is TRUE, R will multiply num by negative one, which will make num positive:\nnum &lt;- -2\n\nif (num &lt; 0) {\n  num &lt;- num * -1\n}\n\nnum\n## 2\nIf num &lt; 0 is FALSE, R will do nothing and num will remain as it is—positive (or zero):\nnum &lt;- 4\n\nif (num &lt; 0) {\n  num &lt;- num * -1\n}\n\nnum\n## 4\nThe condition of an if statement must evaluate to a single TRUE or FALSE. If the condition creates a vector of TRUEs and FALSEs (which is easier to make than you may think), your if statement will print a warning message and use only the first element of the vector. Remember that you can condense vectors of logical values to a single TRUE or FALSE with the functions any and all.\nYou don’t have to limit your if statements to a single line of code; you can include as many lines as you like between the braces. For example, the following code uses many lines to ensure that num is positive. The additional lines print some informative statements if num begins as a negative number. R will skip the entire code block—print statements and all—if num begins as a positive number:\nnum &lt;- -1\n\nif (num &lt; 0) {\n  print(\"num is negative.\")\n  print(\"Don't worry, I'll fix it.\")\n  num &lt;- num * -1\n  print(\"Now num is positive.\")\n}\n## \"num is negative.\"\n## \"Don't worry, I'll fix it.\"\n## \"Now num is positive.\"\n\nnum\n## 1\nTry the following quizzes to develop your understanding of if statements.\n\n\n\n\n\n\nExercise: Quiz A\n\n\n\nWhat will this return?\nx &lt;- 1\nif (3 == 3) {\n  x &lt;- 2\n}\nx\n\n\nThe code will return the number 2. x begins as 1, and then R encounters the if statement. Since the condition evaluates to TRUE, R will run x &lt;- 2, changing the value of x.\n\n\n\n\n\n\nExercise: Quiz B\n\n\n\nWhat will this return?\n```r\nx &lt;- 1\nif (TRUE) {\n  x &lt;- 2\n}\nx\n\n\nThis code will also return the number 2. It works the same as the code in Quiz A, except the condition in this statement is already TRUE. R doesn’t even need to evaluate it. As a result, the code inside the if statement will be run, and x will be set to 2.\n\n\n\n\n\n\nExercise: Quiz C\n\n\n\nWhat will this return?\nx &lt;- 1\nif (x == 1) {\n  x &lt;- 2\n  if (x == 1) {\n    x &lt;- 3\n  }\n}\nx\n\n\nOnce again, the code will return the number 2. x starts out as 1, and the condition of the first if statement will evaluate to TRUE, which causes R to run the code in the body of the if statement. First, R sets x equal to 2, then R evaluates the second if statement, which is in the body of the first. This time x == 1 will evaluate to FALSE because x now equals 2. As a result, R ignores x &lt;- 3 and exits both if statements."
  },
  {
    "objectID": "programs.html#else-statements",
    "href": "programs.html#else-statements",
    "title": "5  Programs",
    "section": "5.3 else Statements",
    "text": "5.3 else Statements\nif statements tell R what to do when your condition is true, but you can also tell R what to do when the condition is false. else is a counterpart to if that extends an if statement to include a second case. In English, you would say, “If this is true, do plan A; else do plan B.” In R, you would say:\nif (this) {\n  Plan A\n} else {\n  Plan B\n}\nWhen this evaluates to TRUE, R will run the code in the first set of braces, but not the code in the second. When this evaluates to FALSE, R will run the code in the second set of braces, but not the first. You can use this arrangement to cover all of the possible cases. For example, you could write some code that rounds a decimal to the nearest integer.\nStart with a decimal:\na &lt;- 3.14\nThen isolate the decimal component with trunc:\ndec &lt;- a - trunc(a)\ndec\n## 0.14\n\n\n\n\n\n\nNote\n\n\n\ntrunc takes a number and returns only the portion of the number that appears to the left of the decimal place (i.e., the integer part of the number).\n\n\n\n\n\n\n\n\nNote\n\n\n\na - trunc(a) is a convenient way to return the decimal part of a.\n\n\nThen use an if else tree to round the number (either up or down):\nif (dec &gt;= 0.5) {\n  a &lt;- trunc(a) + 1\n} else {\n  a &lt;- trunc(a)\n}\n\na\n## 3\nIf your situation has more than two mutually exclusive cases, you can string multiple if and else statements together by adding a new if statement immediately after else. For example:\na &lt;- 1\nb &lt;- 1\n\nif (a &gt; b) {\n  print(\"A wins!\")\n} else if (a &lt; b) {\n  print(\"B wins!\")\n} else {\n  print(\"Tie.\")\n}\n## \"Tie.\"\nR will work through the if conditions until one evaluates to TRUE, then R will ignore any remaining if and else clauses in the tree. If no conditions evaluate to TRUE, R will run the final else statement.\nIf two if statements describe mutually exclusive events, it is better to join the if statements with an else if than to list them separately. This lets R ignore the second if statement whenever the first returns a TRUE, which saves work.\nYou can use if and else to link the subtasks in your slot-machine function. Open a fresh R script, and copy this code into it. The code will be the skeleton of our final score function. Compare it to the flow chart for score in Figure 5.2:\nif ( # Case 1: all the same &lt;1&gt;) {\n  prize &lt;- # look up the prize &lt;3&gt;\n} else if ( # Case 2: all bars &lt;2&gt; ) {\n  prize &lt;- # assign $5 &lt;4&gt;\n} else {\n  # count cherries &lt;5&gt;\n  prize &lt;- # calculate a prize &lt;7&gt;\n}\n\n# count diamonds &lt;6&gt;\n# double the prize if necessary &lt;8&gt;\nOur skeleton is rather incomplete; there are many sections that are just code comments instead of real code. However, we’ve reduced the program to eight simple subtasks:\n&lt;1&gt; - Test whether the symbols are three of a kind.\n&lt;2&gt; - Test whether the symbols are all bars.\n&lt;3&gt; - Look up the prize for three of a kind based on the common symbol.\n&lt;4&gt; - Assign a prize of $5.\n&lt;5&gt; - Count the number of cherries.\n&lt;6&gt; - Count the number of diamonds.\n&lt;7&gt; - Calculate a prize based on the number of cherries.\n&lt;8&gt; - Adjust the prize for diamonds.\nIf you like, you can reorganize your flow chart around these tasks, as in Figure 5.4. The chart will describe the same strategy, but in a more precise way. I’ll use a diamond shape to symbolize an if else decision.\n\n\n\nFigure 5.4: score can navigate three cases with two if else decisions. We can also break some of our tasks into two steps.\n\n\nNow we can work through the subtasks one at a time, adding R code to the if tree as we go. Each subtask will be easy to solve if you set up a concrete example to work with and try to describe a solution in English before coding in R.\nThe first subtask asks you to test whether the symbols are three of a kind. How should you begin writing the code for this subtask?\nYou know that the final score function will look something like this:\nscore &lt;- function(symbols) {\n\n  # calculate a prize\n\n  prize\n}\nIts argument, symbols, will be the output of get_symbols, a vector that contains three character strings. You could start writing score as I have written it, by defining an object named score and then slowly filling in the body of the function. However, this would be a bad idea. The eventual function will have eight separate parts, and it will not work correctly until all of those parts are written (and themselves work correctly). This means you would have to write the entire score function before you could test any of the subtasks. If score doesn’t work—which is very likely—you will not know which subtask needs fixed.\nYou can save yourself time and headaches if you focus on one subtask at a time. For each subtask, create a concrete example that you can test your code on. For example, you know that score will need to work on a vector named symbols that contains three character strings. If you make a real vector named symbols, you can run the code for many of your subtasks on the vector as you go:\nsymbols &lt;- c(\"7\", \"7\", \"7\")\nIf a piece of code does not work on symbols, you will know that you need to fix it before you move on. You can change the value of symbols from subtask to subtask to ensure that your code works in every situation:\nsymbols &lt;- c(\"B\", \"BB\", \"BBB\")\nsymbols &lt;- c(\"C\", \"DD\", \"0\")\nOnly combine your subtasks into a score function once each subtask works on a concrete example. If you follow this plan, you will spend more time using your functions and less time trying to figure out why they do not work.\nAfter you set up a concrete example, try to describe how you will do the subtask in English. The more precisely you can describe your solution, the easier it will be to write your R code.\nOur first subtask asks us to “test whether the symbols are three of a kind.” This phrase does not suggest any useful R code to me. However, I could describe a more precise test for three of a kind: three symbols will be the same if the first symbol is equal to the second and the second symbol is equal to the third. Or, even more precisely:\nA vector named symbols will contain three of the same symbol if the first element of symbols is equal to the second element of symbols and the second element of symbols is equal to the third element of symbols.\n\n\n\n\n\n\nExercise: Write a Test\n\n\n\nTurn the preceding statement into a logical test written in R. Use your knowledge of logical tests, Boolean operators, and subsetting from R Notation. The test should work with the vector symbols and return a TRUE if and only if each element in symbols is the same. Be sure to test your code on symbols.\n\n\nHere are a couple of ways to test that symbols contains three of the same symbol. The first method parallels the English suggestion above, but there are other ways to do the same test. There is no right or wrong answer, so long as your solution works, which is easy to check because you’ve created a vector named symbols:\nsymbols\n##  \"7\" \"7\" \"7\"\n\nsymbols[1] == symbols[2] & symbols[2] == symbols[3]\n## TRUE\n\nsymbols[1] == symbols[2] & symbols[1] == symbols[3]\n## TRUE\n\nall(symbols == symbols[1])\n## TRUE\nAs your vocabulary of R functions broadens, you’ll think of more ways to do basic tasks. One method that I like for checking three of a kind is:\nlength(unique(symbols) == 1)\nThe unique function returns every unique term that appears in a vector. If your symbols vector contains three of a kind (i.e., one unique term that appears three times), then unique(symbols) will return a vector of length 1.\nNow that you have a working test, you can add it to your slot-machine script:\nsame &lt;- symbols[1] == symbols[2] && symbols[2] == symbols[3]\n\nif (same) {\n  prize &lt;- # look up the prize\n} else if ( # Case 2: all bars ) {\n  prize &lt;- # assign $5\n} else {\n  # count cherries\n  prize &lt;- # calculate a prize\n}\n\n# count diamonds\n# double the prize if necessary\n\n\n\n\n\n\nNote\n\n\n\n&& and || behave like & and | but can sometimes be more efficient. The double operators will not evaluate the second test in a pair of tests if the first test makes the result clear. For example, if symbols[1] does not equal symbols[2] in the next expression, && will not evaluate symbols[2] == symbols[3]; it can immediately return a FALSE for the whole expression (because FALSE & TRUE and FALSE & FALSE both evaluate to FALSE). This efficiency can speed up your programs; however, double operators are not appropriate everywhere. && and || are not vectorized, which means they can only handle a single logical test on each side of the operator.\n\n\nThe second prize case occurs when all the symbols are a type of bar, for example, B, BB, and BBB. Let’s begin by creating a concrete example to work with:\nsymbols &lt;- c(\"B\", \"BBB\", \"BB\")\n\n\n\n\n\n\nExercise: Test for All Bars\n\n\n\nUse R’s logical and Boolean operators to write a test that will determine whether a vector named symbols contains only symbols that are a type of bar. Check whether your test works with our example symbols vector. Remember to describe how the test should work in English, and then convert the solution to R.\n\n\nAs with many things in R, there are multiple ways to test whether symbols contains all bars. For example, you could write a very long test that uses multiple Boolean operators, like this:\n(symbols[1] == \"B\" | symbols[1] == \"BB\" | symbols[1] == \"BBB\") &\n  (symbols[2] == \"B\" | symbols[2] == \"BB\" | symbols[2] == \"BBB\") &\n  (symbols[3] == \"B\" | symbols[3] == \"BB\" | symbols[3] == \"BBB\")\n## TRUE\nHowever, this is not a very efficient solution, because R has to run nine logical tests (and you have to type them). You can often replace multiple | operators with a single %in%. Also, you can check that a test is true for each element in a vector with all. These two changes shorten the preceding code to:\nall(symbols %in% c(\"B\", \"BB\", \"BBB\"))\n## TRUE\nLet’s add this code to our script:\nsame &lt;- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars &lt;- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\nif (same) {\n  prize &lt;- # look up the prize\n} else if (all(bars)) {\n  prize &lt;- # assign $5\n} else {\n  # count cherries\n  prize &lt;- # calculate a prize\n}\n\n# count diamonds\n# double the prize if necessary\nYou may have noticed that I split this test up into two steps, bars and all(bars). That’s just a matter of personal preference. Wherever possible, I like to write my code so it can be read with function and object names conveying what they do.\nYou also may have noticed that our test for Case 2 will capture some symbols that should be in Case 1 because they contain three of a kind:\nsymbols &lt;- c(\"B\", \"B\", \"B\")\nall(symbols %in% c(\"B\", \"BB\", \"BBB\"))\n## TRUE\nThat won’t be a problem, however, because we’ve connected our cases with else if in the if tree. As soon as R comes to a case that evaluates to TRUE, it will skip over the rest of the tree. Think of it this way: each else tells R to only run the code that follows it if none of the previous conditions have been met. So when we have three of the same type of bar, R will evaluate the code for Case 1 and then skip the code for Case 2 (and Case 3).\nOur next subtask is to assign a prize for symbols. When the symbols vector contains three of the same symbol, the prize will depend on which symbol there are three of. If there are three DDs, the prize will be $100; if there are three 7s, the prize will be $80; and so on.\nThis suggests another if tree. You could assign a prize with some code like this:\nif (same) {\n  symbol &lt;- symbols[1]\n  if (symbol == \"DD\") {\n    prize &lt;- 800\n  } else if (symbol == \"7\") {\n    prize &lt;- 80\n  } else if (symbol == \"BBB\") {\n    prize &lt;- 40\n  } else if (symbol == \"BB\") {\n    prize &lt;- 5\n  } else if (symbol == \"B\") {\n    prize &lt;- 10\n  } else if (symbol == \"C\") {\n    prize &lt;- 10\n  } else if (symbol == \"0\") {\n    prize &lt;- 0\n  }\n}\nWhile this code will work, it is a bit long to write and read, and it may require R to perform multiple logical tests before delivering the correct prize. We can do better with a different method."
  },
  {
    "objectID": "programs.html#lookup-tables",
    "href": "programs.html#lookup-tables",
    "title": "5  Programs",
    "section": "5.4 Lookup Tables",
    "text": "5.4 Lookup Tables\nVery often in R, the simplest way to do something will involve subsetting. How could you use subsetting here? Since you know the exact relationship between the symbols and their prizes, you can create a vector that captures this information. This vector can store symbols as names and prize values as elements:\npayouts &lt;- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n  \"B\" = 10, \"C\" = 10, \"0\" = 0)\npayouts\n##  DD   7 BBB  BB   B   C   0 \n## 100  80  40  25  10  10   0 \nNow you can extract the correct prize for any symbol by subsetting the vector with the symbol’s name:\npayouts[\"DD\"]\n##  DD \n## 100 \n\npayouts[\"B\"]\n##  B\n## 10\nIf you want to leave behind the symbol’s name when subsetting, you can run the unname function on the output:\nunname(payouts[\"DD\"])\n## 100 \nunname returns a copy of an object with the names attribute removed.\npayouts is a type of lookup table, an R object that you can use to look up values. Subsetting payouts provides a simple way to find the prize for a symbol. It doesn’t take many lines of code, and it does the same amount of work whether your symbol is DD or 0. You can create lookup tables in R by creating named objects that can be subsetted in clever ways.\nSadly, our method is not quite automatic; we need to tell R which symbol to look up in payouts. Or do we? What would happen if you subsetted payouts by symbols[1]? Give it a try:\nsymbols &lt;- c(\"7\", \"7\", \"7\")\nsymbols[1]\n## \"7\"\n\npayouts[symbols[1]]\n##  7 \n## 80 \n\nsymbols &lt;- c(\"C\", \"C\", \"C\")\npayouts[symbols[1]]\n##  C \n## 10 \nYou don’t need to know the exact symbol to look up because you can tell R to look up whichever symbol happens to be in symbols. You can find this symbol with symbols[1], symbols[2], or symbols[3], because each contains the same symbol in this case. You now have a simple automated way to calculate the prize when symbols contains three of a kind. Let’s add it to our code and then look at Case 2:\nsame &lt;- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars &lt;- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\nif (same) {\n  payouts &lt;- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  prize &lt;- unname(payouts[symbols[1]])\n} else if (all(bars)) {\n  prize &lt;- # assign $5\n} else {\n  # count cherries\n  prize &lt;- # calculate a prize\n}\n\n# count diamonds\n# double the prize if necessary\nCase 2 occurs whenever the symbols are all bars. In that case, the prize will be $5, which is easy to assign:\nsame &lt;- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars &lt;- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\nif (same) {\n  payouts &lt;- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  prize &lt;- unname(payouts[symbols[1]])\n} else if (all(bars)) {\n  prize &lt;- 5\n} else {\n  # count cherries\n  prize &lt;- # calculate a prize\n}\n\n# count diamonds\n# double the prize if necessary\nNow we can work on the last case. Here, you’ll need to know how many cherries are in symbols before you can calculate a prize.\n\n\n\n\n\n\nExercise: Find C’s\n\n\n\nHow can you tell which elements of a vector named symbols are a C? Devise a test and try it out.\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nHow might you count the number of Cs in a vector named symbols? Remember R’s coercion rules.\n\n\nAs always, let’s work with a real example:\nsymbols &lt;- c(\"C\", \"DD\", \"C\")\nOne way to test for cherries would be to check which, if any, of the symbols are a C:\nsymbols == \"C\"\n## TRUE FALSE  TRUE\nIt’d be even more useful to count how many of the symbols are cherries. You can do this with sum, which expects numeric input, not logical. Knowing this, R will coerce the TRUEs and FALSEs to 1s and 0s before doing the summation. As a result, sum will return the number of TRUEs, which is also the number of cherries:\nsum(symbols == \"C\")\n## 2\nYou can use the same method to count the number of diamonds in symbols:\nsum(symbols == \"DD\")\n## 1\nLet’s add both of these subtasks to the program skeleton:\nsame &lt;- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars &lt;- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\nif (same) {\n  payouts &lt;- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  prize &lt;- unname(payouts[symbols[1]])\n} else if (all(bars)) {\n  prize &lt;- 5\n} else {\n  cherries &lt;- sum(symbols == \"C\")\n  prize &lt;- # calculate a prize\n}\n\ndiamonds &lt;- sum(symbols == \"DD\")\n# double the prize if necessary\nSince Case 3 appears further down the if tree than Cases 1 and 2, the code in Case 3 will only be applied to players that do not have three of a kind or all bars. According to the slot machine’s payout scheme, these players will win $5 if they have two cherries and $2 if they have one cherry. If the player has no cherries, she gets a prize of $0. We don’t need to worry about three cherries because that outcome is already covered in Case 1.\nAs in Case 1, you could write an if tree that handles each combination of cherries, but just like in Case 1, this would be an inefficient solution:\nif (cherries == 2) {\n  prize &lt;- 5\n} else if (cherries == 1) {\n  prize &lt;- 2\n} else {}\n  prize &lt;- 0\n}\nAgain, I think the best solution will involve subsetting. If you are feeling ambitious, you can try to work this solution out on your own, but you will learn just as quickly by mentally working through the following proposed solution.\nWe know that our prize should be $0 if we have no cherries, $2 if we have one cherry, and $5 if we have two cherries. You can create a vector that contains this information. This will be a very simple lookup table:\nc(0, 2, 5)\nNow, like in Case 1, you can subset the vector to retrieve the correct prize. In this case, the prize’s aren’t identified by a symbol name, but by the number of cherries present. Do we have that information? Yes, it is stored in cherries. We can use basic integer subsetting to get the correct prize from the prior lookup table, for example, c(0, 2, 5)[1].\ncherries isn’t exactly suited for integer subsetting because it could contain a zero, but that’s easy to fix. We can subset with cherries + 1. Now when cherries equals zero, we have:\ncherries + 1\n## 1\n\nc(0, 2, 5)[cherries + 1]\n## 0\nWhen cherries equals one, we have:\ncherries + 1\n## 2\n\nc(0, 2, 5)[cherries + 1]\n## 2\nAnd when cherries equals two, we have:\ncherries + 1\n## 3\n\nc(0, 2, 5)[cherries + 1]\n## 5\nExamine these solutions until you are satisfied that they return the correct prize for each number of cherries. Then add the code to your script, as follows:\nsame &lt;- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars &lt;- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\nif (same) {\n  payouts &lt;- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  prize &lt;- unname(payouts[symbols[1]])\n} else if (all(bars)) {\n  prize &lt;- 5\n} else {\n  cherries &lt;- sum(symbols == \"C\")\n  prize &lt;- c(0, 2, 5)[cherries + 1]\n}\n\ndiamonds &lt;- sum(symbols == \"DD\")\n# double the prize if necessary\n\n\n\n\n\n\nLookup Tables Versus if Trees\n\n\n\nThis is the second time we’ve created a lookup table to avoid writing an if tree. Why is this technique helpful and why does it keep appearing? Many if trees in R are essential. They provide a useful way to tell R to use different algorithms in different cases. However, if trees are not appropriate everywhere.\nif trees have a couple of drawbacks. First, they require R to run multiple tests as it works its way down the if tree, which can create unnecessary work. Second, as you’ll see in Speed, it can be difficult to use if trees in vectorized code, a style of code that takes advantage of R’s programming strengths to create fast programs. Lookup tables do not suffer from either of these drawbacks.\nYou won’t be able to replace every if tree with a lookup table, nor should you. However, you can usually use lookup tables to avoid assigning variables with if trees. As a general rule, use an if tree if each branch of the tree runs different code. Use a lookup table if each branch of the tree only assigns a different value.\nTo convert an if tree to a lookup table, identify the values to be assigned and store them in a vector. Next, identify the selection criteria used in the conditions of the if tree. If the conditions use character strings, give your vector names and use name-based subsetting. If the conditions use integers, use integer-based subsetting.\n\n\nThe final subtask is to double the prize once for every diamond present. This means that the final prize will be some multiple of the current prize. For example, if no diamonds are present, the prize will be:\nprize * 1      # 1 = 2 ^ 0\nIf one diamond is present, it will be:\nprize * 2      # 2 = 2 ^ 1\nIf two diamonds are present, it will be:\nprize * 4      # 4 = 2 ^ 2\nAnd if three diamonds are present, it will be:\nprize * 8      # 8 = 2 ^ 3\nCan you think of an easy way to handle this? How about something similar to these examples?\n\n\n\n\n\n\nExercise: Adjust for Diamonds\n\n\n\nWrite a method for adjusting prize based on diamonds. Describe a solution in English first, and then write your code.\n\n\nHere is a concise solution inspired by the previous pattern. The adjusted prize will equal:\nprize * 2 ^ diamonds\nwhich gives us our final score script:\nsame &lt;- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars &lt;- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\nif (same) {\n  payouts &lt;- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  prize &lt;- unname(payouts[symbols[1]])\n} else if (all(bars)) {\n  prize &lt;- 5\n} else {\n  cherries &lt;- sum(symbols == \"C\")\n  prize &lt;- c(0, 2, 5)[cherries + 1]\n}\n\ndiamonds &lt;- sum(symbols == \"DD\")\nprize * 2 ^ diamonds"
  },
  {
    "objectID": "programs.html#code-comments",
    "href": "programs.html#code-comments",
    "title": "5  Programs",
    "section": "5.5 Code Comments",
    "text": "5.5 Code Comments\nYou now have a working score script that you can save to a function. Before you save your script, though, consider adding comments to your code with a #. Comments can make your code easier to understand by explaining why the code does what it does. You can also use comments to break long programs into scannable chunks. For example, I would include three comments in the score code:\n# identify case\nsame &lt;- symbols[1] == symbols[2] && symbols[2] == symbols[3]\nbars &lt;- symbols %in% c(\"B\", \"BB\", \"BBB\")\n\n# get prize\nif (same) {\n  payouts &lt;- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n    \"B\" = 10, \"C\" = 10, \"0\" = 0)\n  prize &lt;- unname(payouts[symbols[1]])\n} else if (all(bars)) {\n  prize &lt;- 5\n} else {\n  cherries &lt;- sum(symbols == \"C\")\n  prize &lt;- c(0, 2, 5)[cherries + 1]\n}\n\n# adjust for diamonds\ndiamonds &lt;- sum(symbols == \"DD\")\nprize * 2 ^ diamonds\nNow that each part of your code works, you can wrap it into a function with the methods you learned in Writing Your Own Functions. Either use RStudio’s Extract Function option in the menu bar under Code, or use the function function. Ensure that the last line of the function returns a result (it does), and identify any arguments used by your function. Often the concrete examples that you used to test your code, like symbols, will become the arguments of your function. Run the following code to start using the score function:\nscore &lt;- function (symbols) {\n  # identify case\n  same &lt;- symbols[1] == symbols[2] && symbols[2] == symbols[3]\n  bars &lt;- symbols %in% c(\"B\", \"BB\", \"BBB\")\n  \n  # get prize\n  if (same) {\n    payouts &lt;- c(\"DD\" = 100, \"7\" = 80, \"BBB\" = 40, \"BB\" = 25, \n      \"B\" = 10, \"C\" = 10, \"0\" = 0)\n    prize &lt;- unname(payouts[symbols[1]])\n  } else if (all(bars)) {\n    prize &lt;- 5\n  } else {\n    cherries &lt;- sum(symbols == \"C\")\n    prize &lt;- c(0, 2, 5)[cherries + 1]\n  }\n  \n  # adjust for diamonds\n  diamonds &lt;- sum(symbols == \"DD\")\n  prize * 2 ^ diamonds\n}\nOnce you have defined the score function, the play function will work as well:\nplay &lt;- function() {\n  symbols &lt;- get_symbols()\n  print(symbols)\n  score(symbols)\n}\nNow it is easy to play the slot machine:\nplay()\n## \"0\"  \"BB\" \"B\" \n## 0\n\nplay()\n## \"DD\"  \"0\" \"B\"  \n## 0\n\nplay()\n## \"BB\" \"BB\" \"B\" \n## 25"
  },
  {
    "objectID": "programs.html#summary",
    "href": "programs.html#summary",
    "title": "5  Programs",
    "section": "5.6 Summary",
    "text": "5.6 Summary\nAn R program is a set of instructions for your computer to follow that has been organized into a sequence of steps and cases. This may make programs seem simple, but don’t be fooled: you can create complicated results with the right combination of simple steps (and cases).\nAs a programmer, you are more likely to be fooled in the opposite way. A program may seem impossible to write when you know that it must do something impressive. Do not panic in these situations. Divide the job before you into simple tasks, and then divide the tasks again. You can visualize the relationship between tasks with a flow chart if it helps. Then work on the subtasks one at a time. Describe solutions in English, then convert them to R code. Test each solution against concrete examples as you go. Once each of your subtasks works, combine your code into a function that you can share and reuse.\nR provides tools that can help you do this. You can manage cases with if and else statements. You can create a lookup table with objects and subsetting. You can add code comments with #. And you can save your programs as a function with function.\nThings often go wrong when people write programs. It will be up to you to find the source of any errors that occur and to fix them. It should be easy to find the source of your errors if you use a stepwise approach to writing functions, writing—and then testing—one bit at a time. However, if the source of an error eludes you, or you find yourself working with large chunks of untested code, consider using R’s built in debugging tools, described in Debugging R Code.\nThe next two chapters will teach you more tools that you can use in your programs. As you master these tools, you will find it easier to write R programs that let you do whatever you wish to your data. In S3, you will learn how to use R’s S3 system, an invisible hand that shapes many parts of R. You will use the system to build a custom class for your slot machine output, and you will tell R how to display objects that have your class."
  },
  {
    "objectID": "s3.html#the-s3-system",
    "href": "s3.html#the-s3-system",
    "title": "6  S3",
    "section": "6.1 The S3 System",
    "text": "6.1 The S3 System\nS3 refers to a class system built into R. The system governs how R handles objects of different classes. Certain R functions will look up an object’s S3 class, and then behave differently in response.\nThe print function is like this. When you print a numeric vector, print will display a number:\nnum &lt;- 1000000000\nprint(num)\n## 1000000000\nBut if you give that number the S3 class POSIXct followed by POSIXt, print will display a time:\nclass(num) &lt;- c(\"POSIXct\", \"POSIXt\")\nprint(num)\n## \"2001-09-08 19:46:40 CST\"\nIf you use objects with classes—and you do—you will run into R’s S3 system. S3 behavior can seem odd at first, but is easy to predict once you are familiar with it.\nR’s S3 system is built around three components: attributes (especially the class attribute), generic functions, and methods."
  },
  {
    "objectID": "s3.html#attributes",
    "href": "s3.html#attributes",
    "title": "6  S3",
    "section": "6.2 Attributes",
    "text": "6.2 Attributes\nIn Attributes, you learned that many R objects come with attributes, pieces of extra information that are given a name and appended to the object. Attributes do not affect the values of the object, but stick to the object as a type of metadata that R can use to handle the object. For example, a data frame stores its row and column names as attributes. Data frames also store their class, \"data.frame\", as an attribute.\nYou can see an object’s attributes with attribute. If you run attribute on the deck data frame that you created in Project 2: Playing Cards, you will see:\nattributes(deck)\n## $names\n## [1] \"face\"  \"suit\"  \"value\"\n## \n## $class\n## [1] \"data.frame\"\n## \n## $row.names\n##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 \n## [20] 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36\n## [37] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52\nR comes with many helper functions that let you set and access the most common attributes used in R. You’ve already met the names, dim, and class functions, which each work with an eponymously named attribute. However, R also has row.names, levels, and many other attribute-based helper functions. You can use any of these functions to retrieve an attribute’s value:\nrow.names(deck)\n##  [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\" \"11\" \"12\" \"13\"\n## [14] \"14\" \"15\" \"16\" \"17\" \"18\" \"19\" \"20\" \"21\" \"22\" \"23\" \"24\" \"25\" \"26\"\n## [27] \"27\" \"28\" \"29\" \"30\" \"31\" \"32\" \"33\" \"34\" \"35\" \"36\" \"37\" \"38\" \"39\"\n## [40] \"40\" \"41\" \"42\" \"43\" \"44\" \"45\" \"46\" \"47\" \"48\" \"49\" \"50\" \"51\" \"52\"\nor to change an attribute’s value:\nrow.names(deck) &lt;- 101:152\nor to give an object a new attribute altogether:\nlevels(deck) &lt;- c(\"level 1\", \"level 2\", \"level 3\")\n\nattributes(deck)\n## $names\n## [1] \"face\"  \"suit\"  \"value\"\n## \n## $class\n## [1] \"data.frame\"\n## \n## $row.names\n##  [1] 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117\n## [18] 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134\n## [35] 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151\n## [52] 152\n## \n## $levels\n## [1] \"level 1\" \"level 2\" \"level 3\"\nR is very laissez faire when it comes to attributes. It will let you add any attributes that you like to an object (and then it will usually ignore them). The only time R will complain is when a function needs to find an attribute and it is not there.\nYou can add any general attribute to an object with attr; you can also use attr to look up the value of any attribute of an object. Let’s see how this works with one_play, the result of playing our slot machine one time:\none_play &lt;- play()\none_play\n## 0\n\nattributes(one_play)\n## NULL\nattr takes two arguments: an R object and the name of an attribute (as a character string). To give the R object an attribute of the specified name, save a value to the output of attr. Let’s give one_play an attribute named symbols that contains a vector of character strings:\nattr(one_play, \"symbols\") &lt;- c(\"B\", \"0\", \"B\")\n\nattributes(one_play)\n## $symbols\n## [1] \"B\" \"0\" \"B\"\nTo look up the value of any attribute, give attr an R object and the name of the attribute you would like to look up:\nattr(one_play, \"symbols\")\n## \"B\" \"0\" \"B\"\nIf you give an attribute to an atomic vector, like one_play, R will usually display the attribute beneath the vector’s values. However, if the attribute changes the vector’s class, R may display all of the information in the vector in a new way (as we saw with POSIXct objects):\none_play\n## [1] 0\n## attr(,\"symbols\")\n## [1] \"B\" \"0\" \"B\"\nR will generally ignore an object’s attributes unless you give them a name that an R function looks for, like names or class. For example, R will ignore the symbols attribute of one_play as you manipulate one_play:\none_play + 1\n##  1\n## attr(,\"symbols\")\n##  \"B\" \"0\" \"B\"\n\n\n\n\n\n\nExercise: Add an Attribute\n\n\n\nModify play to return a prize that contains the symbols associated with it as an attribute named symbols. Remove the redundant call to print(symbols):\nplay &lt;- function() {\n  symbols &lt;- get_symbols()\n  print(symbols)\n  score(symbols)\n}\n\n\nYou can create a new version of play by capturing the output of score(symbols) and assigning an attribute to it. play can then return the enhanced version of the output:\nplay &lt;- function() {\n  symbols &lt;- get_symbols()\n  prize &lt;- score(symbols)\n  attr(prize, \"symbols\") &lt;- symbols\n  prize\n}\nNow play returns both the prize and the symbols associated with the prize. The results may not look pretty, but the symbols stick with the prize when we copy it to a new object. We can work on tidying up the display in a minute:\nplay()\n## [1] 0\n## attr(,\"symbols\")\n## [1] \"B\"  \"BB\" \"0\" \n \ntwo_play &lt;- play()\n \ntwo_play\n## [1] 0\n## attr(,\"symbols\")\n## [1] \"0\" \"B\" \"0\"\nYou can also generate a prize and set its attributes in one step with the structure function. structure creates an object with a set of attributes. The first argument of structure should be an R object or set of values, and the remaining arguments should be named attributes for structure to add to the object. You can give these arguments any argument names you like. structure will add the attributes to the object under the names that you provide as argument names:\nplay &lt;- function() {\n  symbols &lt;- get_symbols()\n  structure(score(symbols), symbols = symbols)\n}\n\nthree_play &lt;- play()\nthree_play\n##  0\n##  attr(,\"symbols\")\n##  \"0\"  \"BB\" \"B\" \nNow that your play output contains a symbols attribute, what can you do with it? You can write your own functions that lookup and use the attribute. For example, the following function will look up one_play’s symbols attribute and use it to display one_play in a pretty manner. We will use this function to display our slot results, so let’s take a moment to study what it does:\nslot_display &lt;- function(prize){\n\n  # extract symbols\n  symbols &lt;- attr(prize, \"symbols\")\n\n  # collapse symbols into single string\n  symbols &lt;- paste(symbols, collapse = \" \")\n\n  # combine symbol with prize as a character string\n  # \\n is special escape sequence for a new line (i.e. return or enter)\n  string &lt;- paste(symbols, prize, sep = \"\\n$\")\n\n  # display character string in console without quotes\n  cat(string)\n}\n\nslot_display(one_play)\n## B 0 B\n## $0\nThe function expects an object like one_play that has both a numerical value and a symbols attribute. The first line of the function will look up the value of the symbols attribute and save it as an object named symbols. Let’s make an example symbols object so we can see what the rest of the function does. We can use one_play’s symbols attribute to do the job. symbols will be a vector of three-character strings:\nsymbols &lt;- attr(one_play, \"symbols\")\n\nsymbols\n## \"B\" \"0\" \"B\"\nNext, slot_display uses paste to collapse the three strings in symbols into a single-character string. paste collapses a vector of character strings into a single string when you give it the collapse argument. paste will use the value of collapse to separate the formerly distinct strings. Hence, symbols becomes B 0 B the three strings separated by a space:\nsymbols &lt;- paste(symbols, collapse = \" \")\n\nsymbols\n## \"B 0 B\"\nOur function then uses paste in a new way to combine symbols with the value of prize. paste combines separate objects into a character string when you give it a sep argument. For example, here paste will combine the string in symbols, B 0 B, with the number in prize, 0. paste will use the value of sep argument to separate the inputs in the new string. Here, that value is \\n$, so our result will look like \"B 0 B\\n$0\":\nprize &lt;- one_play\nstring &lt;- paste(symbols, prize, sep = \"\\n$\")\n\nstring\n## \"B 0 B\\n$0\"\nThe last line of slot_display calls cat on the new string. cat is like print; it displays its input at the command line. However, cat does not surround its output with quotation marks. cat also replaces every \\n with a new line or line break. The result is what we see. Notice that it looks just how I suggested that our play output should look in Programs:\ncat(string)\n## B 0 B\n## $0\nYou can use slot_display to manually clean up the output of play:\nslot_display(play())\n## C B 0\n## $2\n\nslot_display(play())\n## 7 0 BB\n## $0\nThis method of cleaning the output requires you to manually intervene in your R session (to call slot_display). There is a function that you can use to automatically clean up the output of play each time it is displayed. This function is print, and it is a generic function."
  },
  {
    "objectID": "s3.html#generic-functions",
    "href": "s3.html#generic-functions",
    "title": "6  S3",
    "section": "6.3 Generic Functions",
    "text": "6.3 Generic Functions\nR uses print more often than you may think; R calls print each time it displays a result in your console window. This call happens in the background, so you do not notice it; but the call explains how output makes it to the console window (recall that print always prints its argument in the console window). This print call also explains why the output of print always matches what you see when you display an object at the command line:\nprint(pi)\n## 3.141593\n\npi\n## 3.141593\n\n\nprint(head(deck))\n##  face   suit value\n##  king spades    13\n## queen spades    12\n##  jack spades    11\n##   ten spades    10\n##  nine spades     9\n## eight spades     8\n\nhead(deck)\n##  face   suit value\n##  king spades    13\n## queen spades    12\n##  jack spades    11\n##   ten spades    10\n##  nine spades     9\n## eight spades     8\n\n\nprint(play())\n##  5\n## attr(,\"symbols\")\n##  \"B\"  \"BB\" \"B\" \n\nplay()\n##  5\n## attr(,\"symbols\")\n##  \"B\"  \"BB\" \"B\" \nYou can change how R displays your slot output by rewriting print to look like slot_display. Then R would print the output in our tidy format. However, this method would have negative side effects. You do not want R to call slot_display when it prints a data frame, a numerical vector, or any other object.\nFortunately, print is not a normal function; it is a generic function. This means that print is written in a way that lets it do different things in different cases. You’ve already seen this behavior in action (although you may not have realized it). print did one thing when we looked at the unclassed version of num:\nnum &lt;- 1000000000\nprint(num)\n## 1000000000\nand a different thing when we gave num a class:\nclass(num) &lt;- c(\"POSIXct\", \"POSIXt\")\nprint(num)\n## \"2001-09-08 19:46:40 CST\"\nTake a look at the code inside print to see how it does this. You may imagine that print looks up the class attribute of its input and then uses an +if+ tree to pick which output to display. If this occurred to you, great job! print does something very similar, but much more simple."
  },
  {
    "objectID": "s3.html#methods",
    "href": "s3.html#methods",
    "title": "6  S3",
    "section": "6.4 Methods",
    "text": "6.4 Methods\nWhen you call print, print calls a special function, UseMethod:\nprint\n## function (x, ...) \n## UseMethod(\"print\")\n## &lt;bytecode: 0x7ffee4c62f80&gt;\n## &lt;environment: namespace:base&gt;\nUseMethod examines the class of the input that you provide for the first argument of print, and then passes all of your arguments to a new function designed to handle that class of input. For example, when you give print a POSIXct object, UseMethod will pass all of print’s arguments to print.POSIXct. R will then run print.POSIXct and return the results:\nprint.POSIXct\n## function (x, ...) \n## {\n##     max.print &lt;- getOption(\"max.print\", 9999L)\n##     if (max.print &lt; length(x)) {\n##         print(format(x[seq_len(max.print)], usetz = TRUE), ...)\n##         cat(\" [ reached getOption(\\\"max.print\\\") -- omitted\", \n##             length(x) - max.print, \"entries ]\\n\")\n##     }\n##     else print(format(x, usetz = TRUE), ...)\n##     invisible(x)\n## }\n## &lt;bytecode: 0x7fa948f3d008&gt;\n## &lt;environment: namespace:base&gt;\nIf you give print a factor object, UseMethod will pass all of print’s arguments to print.factor. R will then run print.factor and return the results:\nprint.factor\n## function (x, quote = FALSE, max.levels = NULL, width = getOption(\"width\"), \n##     ...) \n## {\n##     ord &lt;- is.ordered(x)\n##     if (length(x) == 0L) \n##         cat(if (ord) \n##             \"ordered\"\n## ...\n##         drop &lt;- n &gt; maxl\n##         cat(if (drop) \n##             paste(format(n), \"\"), T0, paste(if (drop) \n##             c(lev[1L:max(1, maxl - 1)], \"...\", if (maxl &gt; 1) lev[n])\n##         else lev, collapse = colsep), \"\\n\", sep = \"\")\n##     }\n##     invisible(x)\n## }\n## &lt;bytecode: 0x7fa94a64d470&gt;\n## &lt;environment: namespace:base&gt;\nprint.POSIXct and print.factor are called methods of print. By themselves, print.POSIXct and print.factor work like regular R functions. However, each was written specifically so UseMethod could call it to handle a specific class of print input.\nNotice that print.POSIXct and print.factor do two different things (also notice that I abridged the middle of print.factor—it is a long function). This is how print manages to do different things in different cases. print calls UseMethod, which calls a specialized method based on the class of print’s first argument.\nYou can see which methods exist for a generic function by calling methods on the function. For example, print has almost 200 methods (which gives you an idea of how many classes exist in R):\nmethods(print)\n##   [1] print.acf*                                   \n##   [2] print.anova                                  \n##   [3] print.aov*                                   \n##  ...                      \n## [176] print.xgettext*                              \n## [177] print.xngettext*                             \n## [178] print.xtabs*\n##\n##   Nonvisible functions are asterisked\nThis system of generic functions, methods, and class-based dispatch is known as S3 because it originated in the third version of S, the programming language that would evolve into S-PLUS and R. Many common R functions are S3 generics that work with a set of class methods. For example, summary and head also call UseMethod. More basic functions, like c, +, -, &lt; and others also behave like generic functions, although they call .primitive instead of UseMethod.\nThe S3 system allows R functions to behave in different ways for different classes. You can use S3 to format your slot output. First, give your output its own class. Then write a print method for that class. To do this efficiently, you will need to know a little about how UseMethod selects a method function to use.\n\n6.4.1 Method Dispatch\nUseMethod uses a very simple system to match methods to functions.\nEvery S3 method has a two-part name. The first part of the name will refer to the function that the method works with. The second part will refer to the class. These two parts will be separated by a period. So for example, the print method that works with functions will be called print.function. The summary method that works with matrices will be called summary.matrix. And so on.\nWhen UseMethod needs to call a method, it searches for an R function with the correct S3-style name. The function does not have to be special in any way; it just needs to have the correct name.\nYou can participate in this system by writing your own function and giving it a valid S3-style name. For example, let’s give one_play a class of its own. It doesn’t matter what you call the class; R will store any character string in the class attribute:\nclass(one_play) &lt;- \"slots\"\nNow let’s write an S3 print method for the +slots+ class. The method doesn’t need to do anything special—it doesn’t even need to print one_play. But it does need to be named print.slots; otherwise UseMethod will not find it. The method should also take the same arguments as print; otherwise, R will give an error when it tries to pass the arguments to print.slots:\nargs(print)\n## function (x, ...) \n## NULL\n\nprint.slots &lt;- function(x, ...) {\n  cat(\"I'm using the print.slots method\")\n}\nDoes our method work? Yes, and not only that; R uses the print method to display the contents of one_play. This method isn’t very useful, so I’m going to remove it. You’ll have a chance to write a better one in a minute:\nprint(one_play)\n## I'm using the print.slots method\n\none_play\n## I'm using the print.slots method\n\nrm(print.slots)\nSome R objects have multiple classes. For example, the output of Sys.time has two classes. Which class will UseMethod use to find a print method?\nnow &lt;- Sys.time()\nattributes(now)\n## $class\n## [1] \"POSIXct\" \"POSIXt\" \nUseMethod will first look for a method that matches the first class listed in the object’s class vector. If UseMethod cannot find one, it will then look for the method that matches the second class (and so on if there are more classes in an object’s class vector).\nIf you give print an object whose class or classes do not have a print method, UseMethod will call print.default, a special method written to handle general cases.\nLet’s use this system to write a better print method for the slot machine output.\n\n\n\n\n\n\nExercise: Make a Print Method\n\n\n\nWrite a new print method for the slots class. The method should call slot_display to return well-formatted slot-machine output.\nWhat name must you use for this method?\n\n\nIt is surprisingly easy to write a good print.slots method because we’ve already done all of the hard work when we wrote slot_display. For example, the following method will work. Just make sure the method is named print.slots so UseMethod can find it, and make sure that it takes the same arguments as print so UseMethod can pass those arguments to print.slots without any trouble:\nprint.slots &lt;- function(x, ...) {\n  slot_display(x)\n}\nNow R will automatically use slot_display to display objects of class +slots+ (and only objects of class “slots”):\none_play\n## B 0 B\n## $0\nLet’s ensure that every piece of slot machine output has the slots class.\n\n\n\n\n\n\nExercise: Add a Class\n\n\n\nModify the play function so it assigns slots to the class attribute of its output:\nplay &lt;- function() {\n  symbols &lt;- get_symbols()\n  structure(score(symbols), symbols = symbols)\n}\n\n\nYou can set the class attribute of the output at the same time that you set the +symbols+ attribute. Just add class = \"slots\" to the structure call:\nplay &lt;- function() {\n  symbols &lt;- get_symbols()\n  structure(score(symbols), symbols = symbols, class = \"slots\")\n}\nNow each of our slot machine plays will have the class slots:\nclass(play())\n## \"slots\"\nAs a result, R will display them in the correct slot-machine format:\nplay()\n## BB BB BBB\n## $5\n\nplay()\n## BB 0 0\n## $0"
  },
  {
    "objectID": "s3.html#classes",
    "href": "s3.html#classes",
    "title": "6  S3",
    "section": "6.5 Classes",
    "text": "6.5 Classes\nYou can use the S3 system to make a robust new class of objects in R. Then R will treat objects of your class in a consistent, sensible manner. To make a class:\n\nChoose a name for your class.\nAssign each instance of your class a +class+ attribute.\nWrite class methods for any generic function likely to use objects of your class.\n\nMany R packages are based on classes that have been built in a similar manner. While this work is simple, it may not be easy. For example, consider how many methods exist for predefined classes.\nYou can call methods on a class with the class argument, which takes a character string. methods will return every method written for the class. Notice that methods will not be able to show you methods that come in an unloaded R package:\nmethods(class = \"factor\")\n##  [1] [.factor             [[.factor           \n##  [3] [[&lt;-.factor          [&lt;-.factor          \n##  [5] all.equal.factor     as.character.factor \n##  [7] as.data.frame.factor as.Date.factor      \n##  [9] as.list.factor       as.logical.factor   \n## [11] as.POSIXlt.factor    as.vector.factor    \n## [13] droplevels.factor    format.factor       \n## [15] is.na&lt;-.factor       length&lt;-.factor     \n## [17] levels&lt;-.factor      Math.factor         \n## [19] Ops.factor           plot.factor*        \n## [21] print.factor         relevel.factor*     \n## [23] relist.factor*       rep.factor          \n## [25] summary.factor       Summary.factor      \n## [27] xtfrm.factor        \n## \n##    Nonvisible functions are asterisked\nThis output indicates how much work is required to create a robust, well-behaved class. You will usually need to write a class method for every basic R operation.\nConsider two challenges that you will face right away. First, R drops attributes (like class) when it combines objects into a vector:\nplay1 &lt;- play()\nplay1\n## B BBB BBB\n## $5\n\nplay2 &lt;- play()\nplay2\n## 0 B 0\n## $0\n\nc(play1, play2)\n## [1] 5 0\nHere, R stops using print.slots to display the vector because the vector c(play1, play2) no longer has a “slots” +class+ attribute.\nNext, R will drop the attributes of an object (like class) when you subset the object:\nplay1[1]\n## [1] 5\nYou can avoid this behavior by writing a c.slots method and a [.slots method, but then difficulties will quickly accrue. How would you combine the symbols attributes of multiple plays into a vector of symbols attributes? How would you change print.slots to handle vectors of outputs? These challenges are open for you to explore. However, you will usually not have to attempt this type of large-scale programming as a data scientist.\nIn our case, it is very handy to let slots objects revert to single prize values when we combine groups of them together into a vector."
  },
  {
    "objectID": "s3.html#s3-and-debugging",
    "href": "s3.html#s3-and-debugging",
    "title": "6  S3",
    "section": "6.6 S3 and Debugging",
    "text": "6.6 S3 and Debugging\nS3 can be annoying if you are trying to understand R functions. It is difficult to tell what a function does if its code body contains a call to UseMethod. Now that you know that UseMethod calls a class-specific method, you can search for and examine the method directly. It will be a function whose name follows the &lt;function.class&gt; syntax, or possibly &lt;function.default&gt;. You can also use the methods function to see what methods are associated with a function or a class."
  },
  {
    "objectID": "s3.html#s4-and-r5",
    "href": "s3.html#s4-and-r5",
    "title": "6  S3",
    "section": "6.7 S4 and R5",
    "text": "6.7 S4 and R5\nR also contains two other systems that create class specific behavior. These are known as S4 and R5 (or reference classes). Each of these systems is much harder to use than S3, and perhaps as a consequence, more rare. However, they offer safeguards that S3 does not. If you’d like to learn more about these systems, including how to write and use your own generic functions, I recommend the book Advanced R Programming by Hadley Wickham."
  },
  {
    "objectID": "s3.html#summary",
    "href": "s3.html#summary",
    "title": "6  S3",
    "section": "6.8 Summary",
    "text": "6.8 Summary\nValues are not the only place to store information in R, and functions are not the only way to create unique behavior. You can also do both of these things with R’s S3 system. The S3 system provides a simple way to create object-specific behavior in R. In other words, it is R’s version of object-oriented programming (OOP). The system is implemented by generic functions. These functions examine the class attribute of their input and call a class-specific method to generate output. Many S3 methods will look for and use additional information that is stored in an object’s attributes. Many common R functions are S3 generics.\nR’s S3 system is more helpful for the tasks of computer science than the tasks of data science, but understanding S3 can help you troubleshoot your work in R as a data scientist.\nYou now know quite a bit about how to write R code that performs custom tasks, but how could you repeat these tasks? As a data scientist, you will often repeat tasks, sometimes thousands or even millions of times. Why? Because repetition lets you simulate results and estimate probabilities. Loops will show you how to automate repetition with R’s for and while functions. You’ll use for to simulate various slot machine plays and to calculate the payout rate of your slot machine."
  },
  {
    "objectID": "a1-starting.html#how-to-download-and-install-r",
    "href": "a1-starting.html#how-to-download-and-install-r",
    "title": "Appendix A — Installing R and RStudio",
    "section": "A.1 How to Download and Install R",
    "text": "A.1 How to Download and Install R\nR is maintained by an international team of developers who make the language available through the web page of The Comprehensive R Archive Network. The top of the web page provides three links for downloading R. Follow the link that describes your operating system: Windows, Mac, or Linux.\n\nA.1.1 Windows\nTo install R on Windows, click the “Download R for Windows” link. Then click the “base” link. Next, click the first link at the top of the new page. This link should say something like “Download R 3.0.3 for Windows,” except the 3.0.3 will be replaced by the most current version of R. The link downloads an installer program, which installs the most up-to-date version of R for Windows. Run this program and step through the installation wizard that appears. The wizard will install R into your program files folders and place a shortcut in your Start menu. Note that you’ll need to have all of the appropriate administration privileges to install new software on your machine.\n\n\nA.1.2 Mac\nTo install R on a Mac, click the “Download R for Mac” link. Next, click on the R-3.0.3 package link (or the package link for the most current release of R). An installer will download to guide you through the installation process, which is very easy. The installer lets you customize your installation, but the defaults will be suitable for most users. I’ve never found a reason to change them. If your computer requires a password before installing new progams, you’ll need it here.\n\n\n\n\n\n\nBinaries Versus Source\n\n\n\nR can be installed from precompiled binaries or built from source on any operating system. For Windows and Mac machines, installing R from binaries is extremely easy. The binary comes preloaded in its own installer. Although you can build R from source on these platforms, the process is much more complicated and won’t provide much benefit for most users. For Linux systems, the opposite is true. Precompiled binaries can be found for some systems, but it is much more common to build R from source files when installing on Linux. The download pages on CRAN’s website provide information about building R from source for the Windows, Mac, and Linux platforms.\n\n\n\n\nA.1.3 Linux\nR comes preinstalled on many Linux systems, but you’ll want the newest version of R if yours is out of date. The CRAN website provides files to build R from source on Debian, Redhat, SUSE, and Ubuntu systems under the link “Download R for Linux.” Click the link and then follow the directory trail to the version of Linux you wish to install on. The exact installation procedure will vary depending on the Linux system you use. CRAN guides the process by grouping each set of source files with documentation or README files that explain how to install on your system.\n\n\n\n\n\n\n32-bit Versus 64-bit\n\n\n\nR comes in both 32-bit and 64-bit versions. Which should you use? In most cases, it won’t matter. Both versions use 32-bit integers, which means they compute numbers to the same numerical precision. The difference occurs in the way each version manages memory. 64-bit R uses 64-bit memory pointers, and 32-bit R uses 32-bit memory pointers. This means 64-bit R has a larger memory space to use (and search through).\nAs a rule of thumb, 32-bit builds of R are faster than 64-bit builds, though not always. On the other hand, 64-bit builds can handle larger files and data sets with fewer memory management problems. In either version, the maximum allowable vector size tops out at around 2 billion elements. If your operating system doesn’t support 64-bit programs, or your RAM is less than 4 GB, 32-bit R is for you. The Windows and Mac installers will automatically install both versions if your system supports 64-bit R."
  },
  {
    "objectID": "a1-starting.html#using-r",
    "href": "a1-starting.html#using-r",
    "title": "Appendix A — Installing R and RStudio",
    "section": "A.2 Using R",
    "text": "A.2 Using R\nR isn’t a program that you can open and start using, like Microsoft Word or Internet Explorer. Instead, R is a computer language, like C, C++, or UNIX. You use R by writing commands in the R language and asking your computer to interpret them. In the old days, people ran R code in a UNIX terminal window—as if they were hackers in a movie from the 1980s. Now almost everyone uses R with an application called RStudio, and I recommend that you do, too.\n\n\n\n\n\n\nR and UNIX\n\n\n\nYou can still run R in a UNIX or BASH window by typing the command:\n$ R\nwhich opens an R interpreter. You can then do your work and close the interpreter by running q() when you are finished."
  },
  {
    "objectID": "a1-starting.html#rstudio",
    "href": "a1-starting.html#rstudio",
    "title": "Appendix A — Installing R and RStudio",
    "section": "A.3 RStudio",
    "text": "A.3 RStudio\nRStudio is an application like Microsoft Word—except that instead of helping you write in English, RStudio helps you write in R. I use RStudio throughout the book because it makes using R much easier. Also, the RStudio interface looks the same for Windows, Mac OS, and Linux. That will help me match the book to your personal experience.\nYou can download RStudio for free. Just click the “Download RStudio” button and follow the simple instructions that follow. Once you’ve installed RStudio, you can open it like any other program on your computer—usually by clicking an icon on your desktop.\n\n\n\n\n\n\nThe R GUIs\n\n\n\nWindows and Mac users usually do not program from a terminal window, so the Windows and Mac downloads for R come with a simple program that opens a terminal-like window for you to run R code in. This is what opens when you click the R icon on your Windows or Mac computer. These programs do a little more than the basic terminal window, but not much. You may hear people refer to them as the Windows or Mac R GUIs.\n\n\nWhen you open RStudio, a window appears with three panes in it, as in Figure A.1. The largest pane is a console window. This is where you’ll run your R code and see results. The console window is exactly what you’d see if you ran R from a UNIX console or the Windows or Mac GUIs. Everything else you see is unique to RStudio. Hidden in the other panes are a text editor, a graphics window, a debugger, a file manager, and much more. You’ll learn about these panes as they become useful throughout the course of this book.\n\n\n\nFigure A.1: The RStudio IDE for R.\n\n\n\n\n\n\n\n\nDo I still need to download R?\n\n\n\nEven if you use RStudio, you’ll still need to download R to your computer. RStudio helps you use the version of R that lives on your computer, but it doesn’t come with a version of R on its own."
  },
  {
    "objectID": "a1-starting.html#opening-r",
    "href": "a1-starting.html#opening-r",
    "title": "Appendix A — Installing R and RStudio",
    "section": "A.4 Opening R",
    "text": "A.4 Opening R\nNow that you have both R and RStudio on your computer, you can begin using R by opening the RStudio program. Open RStudio just as you would any program, by clicking on its icon or by typing “RStudio” at the Windows Run prompt."
  },
  {
    "objectID": "a2-packages.html#installing-packages",
    "href": "a2-packages.html#installing-packages",
    "title": "Appendix B — R Packages",
    "section": "B.1 Installing Packages",
    "text": "B.1 Installing Packages\nTo use an R package, you must first install it on your computer and then load it in your current R session. The easiest way to install an R package is with the install.packages R function. Open R and type the following into the command line:\ninstall.packages(\"&lt;package name&gt;\")\nThis will search for the specified package in the collection of packages hosted on the CRAN site. When R finds the package, it will download it into a libraries folder on your computer. R can access the package here in future R sessions without reinstalling it. Anyone can write an R package and disseminate it as they like; however, almost all R packages are published through the CRAN website. CRAN tests each R package before publishing it. This doesn’t eliminate every bug inside a package, but it does mean that you can trust a package on CRAN to run in the current version of R on your OS.\nYou can install multiple packages at once by linking their names with R’s concatenate function, c. For example, to install the ggplot2, reshape2, and dplyr packages, run:\ninstall.packages(c(\"ggplot2\", \"reshape2\", \"dplyr\"))\nIf this is your first time installing a package, R will prompt you to choose an online mirror of to install from. Mirrors are listed by location. Your downloads should be quickest if you select a mirror that is close to you. If you want to download a new package, try the Austria mirror first. This is the main CRAN repository, and new packages can sometimes take a couple of days to make it around to all of the other mirrors."
  },
  {
    "objectID": "a2-packages.html#loading-packages",
    "href": "a2-packages.html#loading-packages",
    "title": "Appendix B — R Packages",
    "section": "B.2 Loading Packages",
    "text": "B.2 Loading Packages\nInstalling a package doesn’t immediately place its functions at your fingertips. It just places them on your computer. To use an R package, you next have to load it in your R session with the command:\nlibrary(&lt;package name&gt;)\nNotice that the quotation marks have disappeared. You can use them if you like, but quotation marks are optional for the library command. (This is not true for the install.packages command).\nlibrary will make all of the package’s functions, data sets, and help files available to you until you close your current R session. The next time you begin an R session, you’ll have to reload the package with library if you want to use it, but you won’t have to reinstall it. You only have to install each package once. After that, a copy of the package will live in your R library. To see which packages you currently have in your R library, run:\nlibrary()\nlibrary() also shows the path to your actual R library, which is the folder that contains your R packages. You may notice many packages that you don’t remember installing. This is because R automatically downloads a set of useful packages when you first install R.\n\n\n\n\n\n\nInstall packages from (almost) anywhere\n\n\n\nThe devtools R package makes it easy to install packages from locations other than the CRAN website. devtools provides functions like install_github, install_gitorious, install_bitbucket, and install_url. These work similar to install.packages, but they search new locations for R packages. install_github is especially useful because many R developers provide development versions of their packages on GitHub. The development version of a package will contain a sneak peek of new functions and patches but may not be as stable or as bug free as the CRAN version.\n\n\nWhy does R make you bother with installing and loading packages? You can imagine an R where every package came preloaded, but this would be a very large and slow program. As of May 6, 2014, the CRAN website hosts 5,511 packages. It is simpler to only install and load the packages that you want to use when you want to use them. This keeps your copy of R fast because it has fewer functions and help pages to search through at any one time. The arrangement has other benefits as well. For example, it is possible to update your copy of an R package without updating your entire copy of R.\n\n\n\n\n\n\nWhat’s the best way to learn about R packages?\n\n\n\nIt is difficult to use an R package if you don’t know that it exists. You could go to the CRAN website and click the Packages link to see a list of available packages, but you’ll have to wade through thousands of them. Moreover, many R packages do the same things.\nHow do you know which package does them best? The R-packages mailing list is a place to start. It sends out announcements of new packages and maintains an archive of old announcements. Blogs that aggregate posts about R can also provide valuable leads. I recommend R-bloggers. RStudio maintains a list of some of the most useful R packages in the Getting Started section of http://support.rstudio.com. Finally, CRAN groups together some of the most useful—and most respected—packages by subject area. This is an excellent place to learn about the packages designed for your area of work."
  }
]